struct PrimitiveInfo
{
    uint _meshInstanceIndex;
    uint _materialIndex;
    float3 _worldPosition;
    float2 _texcoords;
    float2 _ddx;
    float2 _ddy;
};

struct Barycentrics
{
    float3 UVW;
    float3 UVW_dx;
    float3 UVW_dy;
};

/** Calculates perspective correct barycentric coordinates and partial derivatives using screen derivatives. */
Barycentrics CalculateTriangleBarycentrics(float2 PixelClip, float4 PointClip0, float4 PointClip1, float4 PointClip2, float2 ViewInvSize)
{
    Barycentrics Result;

    float3 Pos0 = PointClip0.xyz / PointClip0.w;
    float3 Pos1 = PointClip1.xyz / PointClip1.w;
    float3 Pos2 = PointClip2.xyz / PointClip2.w;

    float3 RcpW = rcp(float3(PointClip0.w, PointClip1.w, PointClip2.w));

    float3 Pos120X = float3(Pos1.x, Pos2.x, Pos0.x);
    float3 Pos120Y = float3(Pos1.y, Pos2.y, Pos0.y);
    float3 Pos201X = float3(Pos2.x, Pos0.x, Pos1.x);
    float3 Pos201Y = float3(Pos2.y, Pos0.y, Pos1.y);

    float3 C_dx = Pos201Y - Pos120Y;
    float3 C_dy = Pos120X - Pos201X;

    float3 C = C_dx * (PixelClip.x - Pos120X) + C_dy * (PixelClip.y - Pos120Y); // Evaluate the 3 edge functions
    float3 G = C * RcpW;

    float H = dot(C, RcpW);
    float RcpH = rcp(H);

	// UVW = C * RcpW / dot(C, RcpW)
    Result.UVW = G * RcpH;

	// Texture coordinate derivatives:
	// UVW = G / H where G = C * RcpW and H = dot(C, RcpW)
	// UVW' = (G' * H - G * H') / H^2
	// float2 TexCoordDX = UVW_dx.y * TexCoord10 + UVW_dx.z * TexCoord20;
	// float2 TexCoordDY = UVW_dy.y * TexCoord10 + UVW_dy.z * TexCoord20;
    float3 G_dx = C_dx * RcpW;
    float3 G_dy = C_dy * RcpW;

    float H_dx = dot(C_dx, RcpW);
    float H_dy = dot(C_dy, RcpW);

    Result.UVW_dx = (G_dx * H - G * H_dx) * (RcpH * RcpH) * (2.0f * ViewInvSize.x);
    Result.UVW_dy = (G_dy * H - G * H_dy) * (RcpH * RcpH) * (-2.0f * ViewInvSize.y);

    return Result;
}