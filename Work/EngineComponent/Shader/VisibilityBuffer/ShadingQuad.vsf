#include "../Def.sfh"

struct VSInput
{
    uint _vertexId : SV_VertexId;
    uint _instanceIndex : SV_InstanceID;
};

struct PSInput
{
    float4 _position : SV_Position;
};

struct ShadingInfo
{
    float2 _quadNdcSize;
    uint2 _shaderRangeResolution;
};

struct PipelineSetInfo
{
    uint _pipelineSetIndex;
};

ConstantBuffer<PipelineSetInfo> _pipelineSetInfo : register(b0);
ConstantBuffer<ShadingInfo> _shadingInfo : register(b1);
ByteAddressBuffer _shaderRangeMin : register(t0);
ByteAddressBuffer _shaderRangeMax : register(t1);

PSInput main(VSInput input)
{
    PSInput result = (PSInput) 0;
    uint triangleIndex = input._vertexId / 3;
    float x = 0;
    float y = 0;
    float2 ndcQuadSize = _shadingInfo._quadNdcSize;
    float2 ndcHalfQuadSize = ndcQuadSize / 2.0;
    if (triangleIndex == 0)
    {
        x = input._vertexId % 3 == 0 ? ndcQuadSize.x : -ndcQuadSize.x;
        y = input._vertexId % 3 == 2 ? ndcQuadSize.y : -ndcQuadSize.y;
    }
    else
    {
        x = input._vertexId % 3 == 1 ? -ndcQuadSize.x : ndcQuadSize.x;
        y = input._vertexId % 3 == 0 ? -ndcQuadSize.y : ndcQuadSize.y;
    }
    
    uint instanceIndex = input._instanceIndex;
    float2 quadUv = float2(instanceIndex % _shadingInfo._shaderRangeResolution.x, (_shadingInfo._shaderRangeResolution.y - 1) -
    instanceIndex / _shadingInfo._shaderRangeResolution.x) * 2;
    x += quadUv.x * ndcQuadSize.x - 1.0 + ndcQuadSize.x;
    y += quadUv.y * ndcQuadSize.y - 1.0 + ndcQuadSize.y;
    
    // シェーダーインデックスが範囲外の場合、NANをセットしてラスタライズを棄却
    uint2 shaderRange = uint2(_shaderRangeMin.Load(instanceIndex * UINT32_SIZE_IN_BYTE), _shaderRangeMax.Load(instanceIndex * UINT32_SIZE_IN_BYTE));
    uint shaderIndex = _pipelineSetInfo._pipelineSetIndex;
    if (shaderIndex < shaderRange.x || shaderIndex > shaderRange.y)
    {
        x = POS_NAN;
    }
    
    
    float shaderRangeUnorm = shaderIndex / float(UINT16_MAX);
    result._position = float4(x, y, shaderRangeUnorm, 1);

    return result;
}
