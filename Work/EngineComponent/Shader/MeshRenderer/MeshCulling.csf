#define FLT_MAX 3.402823466e+38
#define EPSILON 0.000001
#define UINT16_SIZE_IN_BYTE 2
#define UINT32_SIZE_IN_BYTE 4
#define UINT16_MAX 65535
#define UINT32_MAX 4294967295
#define POS_NAN 0x7f800000

struct IndirectArgument
{
    uint _indexCountPerInstance;
    uint _instanceCount;
    uint _startIndexLocation;
    int _baseVertexLocation;
    uint _startInstanceLocation;
};

#define FRUSTUM_PLANE_COUNT 6
struct ViewInfo
{
    float4x4 _matrixView;
    float4x4 _matrixProj;
    float4x4 _matrixViewProj;
    float3 _cameraPosition;
    uint _padding1;
    float2 _nearAndFarClip;
    float2 _halfFovTan;
    uint2 _viewPortSize;
    uint2 _padding2;
    float3 _upDirection;
    uint _debugVisualizeType;
    float4 _frustumPlanes[FRUSTUM_PLANE_COUNT];
};

struct CullingInfo
{
    uint _meshInstanceReserveCount;
};

struct Mesh
{
    uint _lodMeshOffset;
    uint _lodMeshCount;
    uint _streamedLodLevel;
};

struct LodMesh
{
    uint _vertexOffset;
    uint _subMeshOffset;
    uint _subMeshCount;
};

struct SubMesh
{
    uint _indexCount;
    uint _indexOffset;
};

struct MeshInstance
{
    uint _stateFlags;
    uint _meshIndex;
    uint _lodMeshInstanceOffset;
    float _boundsRadius;
    float3 _aabbMin;
    float3 _aabbMax;
    float _worldScale;
};

struct LodMeshInstance
{
    uint _subMeshInstanceOffset;
    float _threshhold;
};

struct SubMeshInstance
{
    uint _materialIndex;
    uint _shaderSetIndex;
};

ConstantBuffer<CullingInfo> _cullingInfo : register(b0);
ConstantBuffer<ViewInfo> _viewInfo : register(b2);

StructuredBuffer<Mesh> _meshes : register(t0);
StructuredBuffer<LodMesh> _lodMeshes : register(t1);
StructuredBuffer<SubMesh> _subMeshes : register(t2);
StructuredBuffer<MeshInstance> _meshInstances : register(t4);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t5);
StructuredBuffer<SubMeshInstance> _subMeshInstances : register(t6);
ByteAddressBuffer _indirectArgumentOffsets : register(t7);
ByteAddressBuffer _currentLodLevels : register(t8);
//StructuredBuffer<SubMeshDrawInfo> _subMeshDrawInfos : register(t9);
//ByteAddressBuffer _materialInstanceIndices : register(t10);
#if UBER_OCCLUSION
Texture2D<float> _hizTextures[] : register(t13);
#endif

RWStructuredBuffer<IndirectArgument> _indirectArguments : register(u0);
RWByteAddressBuffer _countBuffer : register(u1);

[numthreads(128, 1, 1)]
void main(uint gid : SV_GroupID, uint gtid : SV_GroupThreadID, uint dtid : SV_DispatchThreadID) {
    uint meshInstanceIndex = dtid;
    if (_cullingInfo._meshInstanceReserveCount >= dtid)
    {
        return;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    if (meshInstance._stateFlags == 0)
    {
        return;
    }
    
    Mesh mesh = _meshes[meshInstance._meshIndex];
    //uint lodLevel = getCurrentLodLevel(meshInstanceIndex);
    uint lodLevel = 0;
	
    LodMesh lodMesh = _lodMeshes[mesh._lodMeshOffset + lodLevel];
    uint subMeshCount = lodMesh._subMeshCount;
    
    LodMeshInstance lodMeshInstance = _lodMeshInstances[meshInstance._lodMeshInstanceOffset + lodLevel];
    for (uint subMeshLocalIndex = 0; subMeshLocalIndex < subMeshCount; ++subMeshLocalIndex)
    {
        uint subMeshInstanceIndex = lodMeshInstance._subMeshInstanceOffset + subMeshLocalIndex;
        SubMesh subMesh = _subMeshes[lodMesh._subMeshOffset + subMeshLocalIndex];
        SubMeshInstance subMeshInstance = _subMeshInstances[subMeshInstanceIndex];
			
        //uint materialInstanceOffsetByte = subMeshInstance._materialIndex * UINT32_SIZE_IN_BYTE;
        //uint materialInstanceIndex = _materialInstanceIndices.Load(materialInstanceOffsetByte);
        
        uint indirectArgumentMaterialArrayOffset = 0;
        uint currentCountIndex = 0;
        _countBuffer.InterlockedAdd(indirectArgumentMaterialArrayOffset, 1, currentCountIndex);
	
        uint indirectArgumentMaterialOffset = _indirectArgumentOffsets.Load(indirectArgumentMaterialArrayOffset);
        uint indirectArgumentOffset = indirectArgumentMaterialOffset + currentCountIndex;
		
        IndirectArgument arguments;
        //arguments._meshInstanceIndex = meshInstanceIndex;
        //arguments._materialIndex = materialInstanceIndex;
        //arguments._triangleOffset = subMeshDrawInfo._indexOffset / 3;
        arguments._indexCountPerInstance = subMesh._indexCount;
        arguments._startIndexLocation = subMesh._indexOffset;
        arguments._instanceCount = 1;
        arguments._startInstanceLocation = 0;
        arguments._baseVertexLocation = lodMesh._vertexOffset;
        _indirectArguments[indirectArgumentOffset] = arguments;
    }
}