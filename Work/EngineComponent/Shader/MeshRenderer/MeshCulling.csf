#include "../ViewInfo.sfh"
#include "MeshDef.sfh"

struct IndirectArgument
{
    uint _indexCountPerInstance;
    uint _instanceCount;
    uint _startIndexLocation;
    int _baseVertexLocation;
    uint _startInstanceLocation;
};

struct CullingResult
{
    uint _testFrustumCullingSubMeshInstanceCount;
    uint _passFrustumCullingSubMeshInstanceCount;
    uint _testOcclusionCullingSubMeshInstanceCount;
    uint _passOcclusionCullingSubMeshInstanceCount;
    uint _testOcclusionCullingMeshInstanceCount;
    uint _passOcclusionCullingMeshInstanceCount;
    uint _testFrustumCullingMeshInstanceCount;
    uint _passFrustumCullingMeshInstanceCount;
    uint _testFrustumCullingTriangleCount;
    uint _passFrustumCullingTriangleCount;
    uint _testOcclusionCullingTriangleCount;
    uint _passOcclusionCullingTriangleCount;
};

#define OFFSET_testFrustumCullingSubMeshInstanceCount (UINT32_SIZE_IN_BYTE * 0)
#define OFFSET_passFrustumCullingSubMeshInstanceCount (UINT32_SIZE_IN_BYTE * 1)
#define OFFSET_testOcclusionCullingSubMeshInstanceCount (UINT32_SIZE_IN_BYTE * 2)
#define OFFSET_passOcclusionCullingSubMeshInstanceCount (UINT32_SIZE_IN_BYTE * 3)
#define OFFSET_testOcclusionCullingMeshInstanceCount (UINT32_SIZE_IN_BYTE * 4)
#define OFFSET_passOcclusionCullingMeshInstanceCount (UINT32_SIZE_IN_BYTE * 5)
#define OFFSET_testFrustumCullingMeshInstanceCount (UINT32_SIZE_IN_BYTE * 6)
#define OFFSET_passFrustumCullingMeshInstanceCount (UINT32_SIZE_IN_BYTE * 7)
#define OFFSET_testFrustumCullingTriangleCount (UINT32_SIZE_IN_BYTE * 8)
#define OFFSET_passFrustumCullingTriangleCount (UINT32_SIZE_IN_BYTE * 9)
#define OFFSET_testOcclusionCullingTriangleCount (UINT32_SIZE_IN_BYTE * 10)
#define OFFSET_passOcclusionCullingTriangleCount (UINT32_SIZE_IN_BYTE * 11)

ConstantBuffer<CullingInfo> _cullingInfo : register(b0);
ConstantBuffer<ViewInfo> _viewInfo : register(b1);

ByteAddressBuffer _meshes : register(t0);
ByteAddressBuffer _lodMeshes : register(t1);
ByteAddressBuffer _subMeshes : register(t2);
ByteAddressBuffer _meshInstances : register(t4);
ByteAddressBuffer _lodMeshInstances : register(t5);
ByteAddressBuffer _subMeshInstances : register(t6);
ByteAddressBuffer _indirectArgumentOffsets : register(t7);
ByteAddressBuffer _geometryGlobalOffsets : register(t8);
ByteAddressBuffer _meshInstanceLodLevels : register(t9);
ByteAddressBuffer _meshLodStreamRanges : register(t10);
#if UBER_OCCLUSION
Texture2D<float> _hizTextures[] : register(t13);
#endif

RWByteAddressBuffer _indirectArguments : register(u0);
RWByteAddressBuffer _countBuffer : register(u1);
RWByteAddressBuffer _indirectArgumentSubInfos : register(u2);
RWByteAddressBuffer _cullingResult : register(u3);

// 平面の法線方向に最も近いAABBのコーナーポイントを探す
float3 getPositivePoint(float3 boundsMin, float3 boundsMax, float3 planeNormal)
{
    float3 result = boundsMin;
    float3 size = boundsMax - boundsMin;

    result.x += planeNormal.x > 0.0 ? size.x : 0.0;
    result.y += planeNormal.y > 0.0 ? size.y : 0.0;
    result.z += planeNormal.z > 0.0 ? size.z : 0.0;
    return result;
}

bool doFrustumCulling(float3 boundMin, float3 boundsMax, ViewInfo viewInfo) {
    [unroll]
    for (uint i = 0; i < FRUSTUM_PLANE_COUNT; ++i) {
        float4 planeNormal = viewInfo._frustumPlanes[i];
        float3 positivePoint = getPositivePoint(boundMin, boundsMax, planeNormal.xyz);
        float length = dot(planeNormal.xyz, positivePoint) - planeNormal.w;

        if (length < 0) {
            return false;
        }
    }
    
    return true;
}

[numthreads(128, 1, 1)]
void main(uint gid : SV_GroupID, uint gtid : SV_GroupThreadID, uint dtid : SV_DispatchThreadID) {
    uint meshInstanceIndex = dtid;
    if (_cullingInfo._meshInstanceReserveCount <= dtid)
    {
        return;
    }
    
    MeshInstance meshInstance = _meshInstances.Load<MeshInstance>(sizeof(MeshInstance) * meshInstanceIndex);
    if (meshInstance._stateFlags == 0)
    {
        return;
    }
    
    Mesh mesh = _meshes.Load<Mesh>(sizeof(Mesh) * meshInstance._meshIndex);
    uint lodLevel = _meshInstanceLodLevels.Load(UINT32_SIZE_IN_BYTE * meshInstanceIndex);
    uint meshLodStreamRange = _meshLodStreamRanges.Load(UINT32_SIZE_IN_BYTE * meshInstance._meshIndex);
    uint meshLodLevelMin = meshLodStreamRange & 0x0000ffff; // 下位 16bit
    uint meshLodLevelMax = (meshLodStreamRange >> 16) & 0x0000ffff; // 上位 16bit
    lodLevel = clamp(lodLevel, meshLodLevelMin, meshLodLevelMax);
    
    // Lod Level が Lod 数より大きい場合はカリング
    if (lodLevel >= mesh._lodMeshCount)
    {
        return;
    }

    float3 boundsMin = meshInstance._aabbMin;
    float3 boundsMax = meshInstance._aabbMax;
    bool passCulling = true;
    bool passFrustum = false;
    bool passOcclusion = false;
    bool testFrustum = false;
    bool testOcclusion = false;
#define UBER_FRUSTUM 1
#if UBER_FRUSTUM
    passFrustum = doFrustumCulling(boundsMin, boundsMax, _viewInfo);
    testFrustum = true;
    passCulling = passFrustum;
#endif
	
    uint lodMeshOffset = mesh._lodMeshOffset + lodLevel;
    LodMesh lodMesh = _lodMeshes.Load<LodMesh>(sizeof(LodMesh) * lodMeshOffset);
    uint subMeshCount = lodMesh._subMeshCount;
    GeometryGlobalOffsetInfo geometryGlobalOffsetInfo = _geometryGlobalOffsets.Load<GeometryGlobalOffsetInfo>(sizeof(GeometryGlobalOffsetInfo) * lodMeshOffset);
    
    {
        uint triangleCount = 0;
        for (uint subMeshLocalIndex = 0; subMeshLocalIndex < subMeshCount; ++subMeshLocalIndex)
        {
            uint subMeshOffset = lodMesh._subMeshOffset + subMeshLocalIndex;
            SubMesh subMesh = _subMeshes.Load<SubMesh>(sizeof(SubMesh) * subMeshOffset);
            triangleCount += subMesh._indexCount / 3;
        }
    
        uint dummy;
        if (testFrustum)
        {
            _cullingResult.InterlockedAdd(OFFSET_testFrustumCullingMeshInstanceCount, 1, dummy);
            _cullingResult.InterlockedAdd(OFFSET_testFrustumCullingSubMeshInstanceCount, subMeshCount, dummy);
            _cullingResult.InterlockedAdd(OFFSET_testFrustumCullingTriangleCount, triangleCount, dummy);
        }
    
        if (passFrustum)
        {
            _cullingResult.InterlockedAdd(OFFSET_passFrustumCullingMeshInstanceCount, 1, dummy);
            _cullingResult.InterlockedAdd(OFFSET_passFrustumCullingSubMeshInstanceCount, subMeshCount, dummy);
            _cullingResult.InterlockedAdd(OFFSET_passFrustumCullingTriangleCount, triangleCount, dummy);
        }
    }
    
    uint lodMeshInstanceOffset = meshInstance._lodMeshInstanceOffset + lodLevel;
    LodMeshInstance lodMeshInstance = _lodMeshInstances.Load<LodMeshInstance>(sizeof(LodMeshInstance) * lodMeshInstanceOffset);
    for (uint subMeshLocalIndex = 0; subMeshLocalIndex < subMeshCount; ++subMeshLocalIndex)
    {
        uint subMeshInstanceIndex = lodMeshInstance._subMeshInstanceOffset + subMeshLocalIndex;
        uint subMeshOffset = lodMesh._subMeshOffset + subMeshLocalIndex;
        SubMesh subMesh = _subMeshes.Load<SubMesh>(sizeof(SubMesh) * subMeshOffset);
        SubMeshInstance subMeshInstance = _subMeshInstances.Load<SubMeshInstance>(sizeof(SubMeshInstance) * subMeshInstanceIndex);
        
        uint indirectArgumentMaterialArrayOffset = 0;
        uint currentCountIndex = 0;
        _countBuffer.InterlockedAdd(indirectArgumentMaterialArrayOffset, 1, currentCountIndex);
	
        uint indirectArgumentMaterialOffset = _indirectArgumentOffsets.Load<uint>(sizeof(uint) * indirectArgumentMaterialArrayOffset);
        uint indirectArgumentOffset = indirectArgumentMaterialOffset + currentCountIndex;
		
        IndirectArgument arguments;
        arguments._indexCountPerInstance = subMesh._indexCount;
        arguments._startIndexLocation = geometryGlobalOffsetInfo._indexOffset + subMesh._indexOffset;
        arguments._instanceCount = 1;
        arguments._startInstanceLocation = indirectArgumentOffset;
        arguments._baseVertexLocation = geometryGlobalOffsetInfo._vertexOffset;
        _indirectArguments.Store(sizeof(IndirectArgument) * indirectArgumentOffset, arguments);
        
        IndirectArgumentSubInfo subInfo;
        subInfo._meshInstanceIndex = meshInstanceIndex;
        subInfo._materialIndex = subMeshInstance._materialIndex;
        subInfo._materialParameterOffset = subMeshInstance._materialParameterOffset;
        _indirectArgumentSubInfos.Store(sizeof(IndirectArgumentSubInfo) * indirectArgumentOffset, subInfo);
    }
}