#include "ShaderInput.sfh"
#include "../ViewInfo.sfh"
#include "../MeshRenderer/MeshDef.sfh"
#include "../VisibilityBuffer/VisibilityBufferUtility.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b0);

ByteAddressBuffer _materialParameters : register(t0);
ByteAddressBuffer _materialParameterOffsets : register(t1);
ByteAddressBuffer _meshes : register(t2);
ByteAddressBuffer _lodMeshes : register(t3);
ByteAddressBuffer _meshInstances : register(t4);
ByteAddressBuffer _meshInstanceLodLevels : register(t5);
ByteAddressBuffer _meshLodStreamRanges : register(t6);
ByteAddressBuffer _geometryGlobalOffsets : register(t7);

ByteAddressBuffer _vertexPositions : register(t8);
ByteAddressBuffer _vertexTexcoords : register(t9);
ByteAddressBuffer _vertexIndices : register(t10);

Texture2D<uint2> _triangleAttributes : register(t11);
Texture2D<float> _viewDepth : register(t12);

Texture2D _textures[] : register(t0, space1);
SamplerState _anisotropicSampler : register(s0);

float3 ReconstructWorldPositionFromDepth(
    in float2 pixelPosition,
    in float depth,
    in float4x4 inverseViewProjection)
{
    float2 textureCoord = pixelPosition / float2(_viewInfo._viewPortSize);
    float4 projectedPosition = float4(
        textureCoord.xy * 2.0 - float2(1.0, 1.0), depth, 1.0);

    float4 position = mul(projectedPosition, inverseViewProjection);
    return position.xyz / position.w;
}

PrimitiveInfo getPrimitiveInfo(float2 pixelPosition)
{
    uint2 triangleAttributes = _triangleAttributes[pixelPosition];

    uint meshInstanceIndex = triangleAttributes.y & 0x0000ffff;
    uint materialIndex = (triangleAttributes.y >> 18) & 0x0000ffff;
    uint currentLodLevel = _meshInstanceLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE);
    
    MeshInstance meshInstance = getMeshInstance(_meshInstances, meshInstanceIndex);
    
    // TODO: Gpu カリング時にも同じように LOD レベルをストリーミング範囲でクランプしているのでまとめる
    uint meshLodStreamRange = _meshLodStreamRanges.Load(UINT32_SIZE_IN_BYTE * meshInstance._meshIndex);
    uint meshLodLevelMin = meshLodStreamRange & 0x0000ffff; // 下位 16bit
    uint meshLodLevelMax = (meshLodStreamRange >> 16) & 0x0000ffff; // 上位 16bit
    currentLodLevel = clamp(currentLodLevel, meshLodLevelMin, meshLodLevelMax);
    
    Mesh mesh = getMesh(_meshes, meshInstance._meshIndex);
    uint lodMeshIndex = mesh._lodMeshOffset + currentLodLevel;
    LodMesh lodMesh = getLodMesh(_lodMeshes, lodMeshIndex);
    GeometryGlobalOffsetInfo geometryGlobalOffsetInfo = getGeometryGlobalOffsetInfo(_geometryGlobalOffsets, lodMeshIndex);
    
    uint3 primitiveIndices = uint3(
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 0) + geometryGlobalOffsetInfo._vertexOffset,
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 1) + geometryGlobalOffsetInfo._vertexOffset,
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 2) + geometryGlobalOffsetInfo._vertexOffset
    );
    const float3 PointLocal0 = loadFloat3(_vertexPositions, primitiveIndices.x);
    const float3 PointLocal1 = loadFloat3(_vertexPositions, primitiveIndices.y);
    const float3 PointLocal2 = loadFloat3(_vertexPositions, primitiveIndices.z);
    
    const float2 texcoords0 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.x));
    const float2 texcoords1 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.y));
    const float2 texcoords2 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.z));
    
    float4x3 matrixWorld = meshInstance._worldMatrix;
    float3 pointToWorld0 = mul(float4(PointLocal0, 1), matrixWorld);
    float3 pointToWorld1 = mul(float4(PointLocal1, 1), matrixWorld);
    float3 pointToWorld2 = mul(float4(PointLocal2, 1), matrixWorld);
    
    const float4 PointClip0 = mul(float4(pointToWorld0, 1), _viewInfo._matrixViewProj);
    const float4 PointClip1 = mul(float4(pointToWorld1, 1), _viewInfo._matrixViewProj);
    const float4 PointClip2 = mul(float4(pointToWorld2, 1), _viewInfo._matrixViewProj);
    
    float2 viewInvSize = float2(1.0, 1.0) / float2(_viewInfo._viewPortSize);
    const float2 PixelClip = (pixelPosition + 0.5) * viewInvSize * float2(2, -2) + float2(-1, 1);
    
    // Calculate perspective correct barycentric coordinates with screen derivatives
    const Barycentrics Barycentrics = CalculateTriangleBarycentrics(PixelClip, PointClip0, PointClip1, PointClip2, viewInvSize);
    
    float3 worldPosition = Barycentrics.UVW.x * pointToWorld0 + Barycentrics.UVW.y * pointToWorld1 + Barycentrics.UVW.z * pointToWorld2;
    float2 texcoords = Barycentrics.UVW.x * texcoords0 + Barycentrics.UVW.y * texcoords1 + Barycentrics.UVW.z * texcoords2;
    
    float2 TexCoord10 = texcoords1 - texcoords0;
    float2 TexCoord20 = texcoords2 - texcoords0;

    float2 TexCoord = texcoords0 + Barycentrics.UVW.y * TexCoord10 + Barycentrics.UVW.z * TexCoord20;
    float2 ddx = Barycentrics.UVW_dx.y * TexCoord10 + Barycentrics.UVW_dx.z * TexCoord20;
    float2 ddy = Barycentrics.UVW_dy.y * TexCoord10 + Barycentrics.UVW_dy.z * TexCoord20;
    
    PrimitiveInfo primitiveInfo;
    primitiveInfo._meshInstanceIndex = meshInstanceIndex;
    primitiveInfo._materialIndex = materialIndex;
    primitiveInfo._worldPosition = worldPosition;
    primitiveInfo._texcoords = texcoords;
    primitiveInfo._ddx = ddx;
    primitiveInfo._ddy = ddy;
    return primitiveInfo;
}