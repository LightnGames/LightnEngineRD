#include "ShaderInput.sfh"
#include "../ViewInfo.sfh"
#include "../MeshRenderer/MeshDef.sfh"
#include "../VisibilityBuffer/VisibilityBufferUtility.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b0);

ByteAddressBuffer _materialParameters : register(t0);
ByteAddressBuffer _materialParameterOffsets : register(t1);
ByteAddressBuffer _meshes : register(t2);
ByteAddressBuffer _lodMeshes : register(t3);
ByteAddressBuffer _meshInstances : register(t4);
ByteAddressBuffer _meshInstanceLodLevels : register(t5);
ByteAddressBuffer _meshLodStreamRanges : register(t6);
ByteAddressBuffer _geometryGlobalOffsets : register(t7);

ByteAddressBuffer _vertexPositions : register(t8);
ByteAddressBuffer _vertexTexcoords : register(t9);
ByteAddressBuffer _vertexNormalTangents : register(t10);
ByteAddressBuffer _vertexIndices : register(t11);

Texture2D<uint2> _triangleAttributes : register(t12);
Texture2D<float2> _baryCentrics : register(t13);
Texture2D<float> _viewDepth : register(t14);

Texture2D _textures[] : register(t0, space1);
SamplerState _anisotropicSampler : register(s0);

PrimitiveInfo getPrimitiveInfo(float2 pixelPosition)
{
    uint2 triangleAttributes = _triangleAttributes[pixelPosition];
    float3 baryCentrics = float3(_baryCentrics[pixelPosition], 0.0);
    baryCentrics.z = saturate(1.0 - baryCentrics.x - baryCentrics.y);

    uint meshInstanceIndex = triangleAttributes.y & 0x0000ffff;
    uint materialIndex = (triangleAttributes.y >> 18) & 0x0000ffff;
    uint currentLodLevel = _meshInstanceLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE);
    
    MeshInstance meshInstance = getMeshInstance(_meshInstances, meshInstanceIndex);
    
    // TODO: Gpu カリング時にも同じように LOD レベルをストリーミング範囲でクランプしているのでまとめる
    uint meshLodStreamRange = _meshLodStreamRanges.Load(UINT32_SIZE_IN_BYTE * meshInstance._meshIndex);
    uint meshLodLevelMin = meshLodStreamRange & 0x0000ffff; // 下位 16bit
    uint meshLodLevelMax = (meshLodStreamRange >> 16) & 0x0000ffff; // 上位 16bit
    currentLodLevel = clamp(currentLodLevel, meshLodLevelMin, meshLodLevelMax);
    
    Mesh mesh = getMesh(_meshes, meshInstance._meshIndex);
    uint lodMeshIndex = mesh._lodMeshOffset + currentLodLevel;
    LodMesh lodMesh = getLodMesh(_lodMeshes, lodMeshIndex);
    GeometryGlobalOffsetInfo geometryGlobalOffsetInfo = getGeometryGlobalOffsetInfo(_geometryGlobalOffsets, lodMeshIndex);
    
    uint3 primitiveIndices = uint3(
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 0) + geometryGlobalOffsetInfo._vertexOffset,
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 1) + geometryGlobalOffsetInfo._vertexOffset,
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 2) + geometryGlobalOffsetInfo._vertexOffset
    );
    float3 pointLocal0 = loadFloat3(_vertexPositions, primitiveIndices.x);
    float3 pointLocal1 = loadFloat3(_vertexPositions, primitiveIndices.y);
    float3 pointLocal2 = loadFloat3(_vertexPositions, primitiveIndices.z);
    
    float2 texcoords0 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.x));
    float2 texcoords1 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.y));
    float2 texcoords2 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.z));
    
    uint normalTangent0 = loadUint(_vertexNormalTangents, primitiveIndices.x);
    uint normalTangent1 = loadUint(_vertexNormalTangents, primitiveIndices.y);
    uint normalTangent2 = loadUint(_vertexNormalTangents, primitiveIndices.z);
    
    float3 normal0 = decodeOctahedron(normalTangent0 & 0xffff);
    float3 normal1 = decodeOctahedron(normalTangent1 & 0xffff);
    float3 normal2 = decodeOctahedron(normalTangent2 & 0xffff);
    
    float3 tangent0 = decodeOctahedron((normalTangent0 >> 16) & 0xffff);
    float3 tangent1 = decodeOctahedron((normalTangent1 >> 16) & 0xffff);
    float3 tangent2 = decodeOctahedron((normalTangent2 >> 16) & 0xffff);
    
    float3 worldPosition = reconstructWorldPositionFromDepth(pixelPosition / float2(_viewInfo._viewPortSize), _viewDepth[pixelPosition], _viewInfo._matrixViewProjInv);
    float3 localPosition = baryCentrics.x * pointLocal0 + baryCentrics.y * pointLocal1 + baryCentrics.z * pointLocal2;
    float2 texcoords = baryCentrics.x * texcoords0 + baryCentrics.y * texcoords1 + baryCentrics.z * texcoords2;
    float3 normal = baryCentrics.x * normal0 + baryCentrics.y * normal1 + baryCentrics.z * normal2;
    float3 tangent = baryCentrics.x * tangent0 + baryCentrics.y * tangent1 + baryCentrics.z * tangent2;
    
    float2 ddx = texcoords - QuadReadAcrossX(texcoords);
    float2 ddy = texcoords - QuadReadAcrossY(texcoords);
    
    PrimitiveInfo primitiveInfo;
    primitiveInfo._meshInstanceIndex = meshInstanceIndex;
    primitiveInfo._materialIndex = materialIndex;
    primitiveInfo._localPosition = localPosition;
    primitiveInfo._worldPosition = worldPosition;
    primitiveInfo._localNormal = normal;
    primitiveInfo._localTangent = tangent;
    primitiveInfo._worldNormal = normalize(mul(normal, (float3x3) meshInstance._worldMatrix));
    primitiveInfo._worldTangent = normalize(mul(tangent, (float3x3) meshInstance._worldMatrix));
    primitiveInfo._texcoords = texcoords;
    primitiveInfo._ddx = ddx;
    primitiveInfo._ddy = ddy;
    return primitiveInfo;
}