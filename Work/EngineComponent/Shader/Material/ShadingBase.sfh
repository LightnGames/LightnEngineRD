#include "ShaderInput.sfh"
#include "../ViewInfo.sfh"
#include "../MeshRenderer/MeshDef.sfh"
#include "../VisibilityBuffer/VisibilityBufferUtility.sfh"
#include "../Lighting/LightingDef.sfh"


#define DEBUG_MATERIAL_TYPE_NONE 0
#define DEBUG_MATERIAL_TYPE_BASE_COLOR 1
#define DEBUG_MATERIAL_TYPE_NORMAL 2
#define DEBUG_MATERIAL_TYPE_METALIC 3
#define DEBUG_MATERIAL_TYPE_ROUGHNESS 4
#define DEBUG_MATERIAL_TYPE_DIRECT_LIGHTING 5
#define DEBUG_MATERIAL_TYPE_INDIRECT_LIGHTING 6
#define DEBUG_MATERIAL_TYPE_INDIRECT_DIFFUSE 7
#define DEBUG_MATERIAL_TYPE_INDIRECT_SPECULAR 8
struct DebugMaterialType
{
    uint _type;
};


ConstantBuffer<ViewInfo> _viewInfo : register(b0);
ConstantBuffer<SkySphere> _skySphere : register(b1);
ConstantBuffer<DebugMaterialType> _debugMaterialType : register(b2);

ByteAddressBuffer _materialParameters : register(t0);
ByteAddressBuffer _materialParameterOffsets : register(t1);
ByteAddressBuffer _meshes : register(t2);
ByteAddressBuffer _lodMeshes : register(t3);
ByteAddressBuffer _meshInstances : register(t4);
ByteAddressBuffer _meshInstanceLodLevels : register(t5);
ByteAddressBuffer _meshLodStreamRanges : register(t6);
ByteAddressBuffer _geometryGlobalOffsets : register(t7);

ByteAddressBuffer _vertexPositions : register(t8);
ByteAddressBuffer _vertexTexcoords : register(t9);
ByteAddressBuffer _vertexNormalTangents : register(t10);
ByteAddressBuffer _vertexIndices : register(t11);

Texture2D<uint2> _triangleAttributes : register(t12);
Texture2D<float2> _baryCentrics : register(t13);
Texture2D<float> _viewDepth : register(t14);

ByteAddressBuffer _directionalLights : register(t15);
TextureCube _skyDiffuse : register(t16);
TextureCube _skySpecular : register(t17);

Texture2D _textures[] : register(t0, space1);
SamplerState _anisotropicSampler : register(s0);
SamplerState _linerSampler : register(s1);

PrimitiveInfo getPrimitiveInfo(float2 pixelPosition)
{
    uint2 triangleAttributes = _triangleAttributes[pixelPosition];
    float3 baryCentrics = float3(_baryCentrics[pixelPosition], 0.0);
    baryCentrics.z = saturate(1.0 - baryCentrics.x - baryCentrics.y);

    uint meshInstanceIndex = triangleAttributes.y & 0x0000ffff;
    uint materialIndex = (triangleAttributes.y >> 18) & 0x0000ffff;
    uint currentLodLevel = _meshInstanceLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE);
    
    MeshInstance meshInstance = getMeshInstance(_meshInstances, meshInstanceIndex);
    
    // TODO: Gpu カリング時にも同じように LOD レベルをストリーミング範囲でクランプしているのでまとめる
    uint meshLodStreamRange = _meshLodStreamRanges.Load(UINT32_SIZE_IN_BYTE * meshInstance._meshIndex);
    uint meshLodLevelMin = meshLodStreamRange & 0x0000ffff; // 下位 16bit
    uint meshLodLevelMax = (meshLodStreamRange >> 16) & 0x0000ffff; // 上位 16bit
    currentLodLevel = clamp(currentLodLevel, meshLodLevelMin, meshLodLevelMax);
    
    Mesh mesh = getMesh(_meshes, meshInstance._meshIndex);
    uint lodMeshIndex = mesh._lodMeshOffset + currentLodLevel;
    LodMesh lodMesh = getLodMesh(_lodMeshes, lodMeshIndex);
    GeometryGlobalOffsetInfo geometryGlobalOffsetInfo = getGeometryGlobalOffsetInfo(_geometryGlobalOffsets, lodMeshIndex);
    
    uint3 primitiveIndices = uint3(
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 0) + geometryGlobalOffsetInfo._vertexOffset,
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 1) + geometryGlobalOffsetInfo._vertexOffset,
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 2) + geometryGlobalOffsetInfo._vertexOffset
    );
    float3 pointLocal0 = loadFloat3(_vertexPositions, primitiveIndices.x);
    float3 pointLocal1 = loadFloat3(_vertexPositions, primitiveIndices.y);
    float3 pointLocal2 = loadFloat3(_vertexPositions, primitiveIndices.z);
    
    float2 texcoords0 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.x));
    float2 texcoords1 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.y));
    float2 texcoords2 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.z));
    
    uint normalTangent0 = loadUint(_vertexNormalTangents, primitiveIndices.x);
    uint normalTangent1 = loadUint(_vertexNormalTangents, primitiveIndices.y);
    uint normalTangent2 = loadUint(_vertexNormalTangents, primitiveIndices.z);
    
    float3 normal0 = decodeOctahedron(normalTangent0 & 0xffff);
    float3 normal1 = decodeOctahedron(normalTangent1 & 0xffff);
    float3 normal2 = decodeOctahedron(normalTangent2 & 0xffff);
    
    float3 tangent0 = decodeOctahedron((normalTangent0 >> 16) & 0xffff);
    float3 tangent1 = decodeOctahedron((normalTangent1 >> 16) & 0xffff);
    float3 tangent2 = decodeOctahedron((normalTangent2 >> 16) & 0xffff);
    
    float4x3 matrixWorld = meshInstance._worldMatrix;
    float3 pointToWorld0 = mul(float4(pointLocal0, 1), matrixWorld);
    float3 pointToWorld1 = mul(float4(pointLocal1, 1), matrixWorld);
    float3 pointToWorld2 = mul(float4(pointLocal2, 1), matrixWorld);
    
    //float3 worldPosition = reconstructWorldPositionFromDepth(pixelPosition / float2(_viewInfo._viewPortSize), _viewDepth[pixelPosition], _viewInfo._matrixViewProjInv);
    float3 worldPosition = baryCentrics.x * pointToWorld0 + baryCentrics.y * pointToWorld1 + baryCentrics.z * pointToWorld2;
    float3 localPosition = baryCentrics.x * pointLocal0 + baryCentrics.y * pointLocal1 + baryCentrics.z * pointLocal2;
    float2 texcoords = baryCentrics.x * texcoords0 + baryCentrics.y * texcoords1 + baryCentrics.z * texcoords2;
    float3 normal = baryCentrics.x * normal0 + baryCentrics.y * normal1 + baryCentrics.z * normal2;
    float3 tangent = baryCentrics.x * tangent0 + baryCentrics.y * tangent1 + baryCentrics.z * tangent2;
    
    float2 ddx = texcoords - QuadReadAcrossX(texcoords);
    float2 ddy = texcoords - QuadReadAcrossY(texcoords);
    
    {   
        const float4 PointClip0 = mul(float4(pointToWorld0, 1), _viewInfo._matrixViewProj);
        const float4 PointClip1 = mul(float4(pointToWorld1, 1), _viewInfo._matrixViewProj);
        const float4 PointClip2 = mul(float4(pointToWorld2, 1), _viewInfo._matrixViewProj);
    
        float2 viewInvSize = float2(1.0, 1.0) / float2(_viewInfo._viewPortSize);
        const float2 PixelClip = (pixelPosition + 0.5) * viewInvSize * float2(2, -2) + float2(-1, 1);
    
        // Calculate perspective correct barycentric coordinates with screen derivatives
        const Barycentrics Barycentrics = CalculateTriangleBarycentrics(PixelClip, PointClip0, PointClip1, PointClip2, viewInvSize);
        
        float2 texcoords = Barycentrics.UVW.x * texcoords0 + Barycentrics.UVW.y * texcoords1 + Barycentrics.UVW.z * texcoords2;
    
        float2 TexCoord10 = texcoords1 - texcoords0;
        float2 TexCoord20 = texcoords2 - texcoords0;

        texcoords = texcoords0 + Barycentrics.UVW.y * TexCoord10 + Barycentrics.UVW.z * TexCoord20;
        ddx = Barycentrics.UVW_dx.y * TexCoord10 + Barycentrics.UVW_dx.z * TexCoord20;
        ddy = Barycentrics.UVW_dy.y * TexCoord10 + Barycentrics.UVW_dy.z * TexCoord20;
    }
    
    PrimitiveInfo primitiveInfo;
    primitiveInfo._meshInstanceIndex = meshInstanceIndex;
    primitiveInfo._materialIndex = materialIndex;
    primitiveInfo._localPosition = localPosition;
    primitiveInfo._worldPosition = worldPosition;
    primitiveInfo._localNormal = normal;
    primitiveInfo._localTangent = tangent;
    primitiveInfo._worldNormal = normalize(mul(normal, (float3x3) meshInstance._worldMatrix));
    primitiveInfo._worldTangent = normalize(mul(tangent, (float3x3) meshInstance._worldMatrix));
    primitiveInfo._texcoords = texcoords;
    primitiveInfo._ddx = ddx;
    primitiveInfo._ddy = ddy;
    return primitiveInfo;
}

Texture2D getTexture(uint textureIndex)
{
    return _textures[NonUniformResourceIndex(textureIndex)];
}

float4 sampleTextureAnisotropic(Texture2D texture, PrimitiveInfo primitiveInfo)
{
    return texture.SampleGrad(_anisotropicSampler, primitiveInfo._texcoords, primitiveInfo._ddx, primitiveInfo._ddy);
}