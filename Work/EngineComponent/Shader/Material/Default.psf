#include "ShadingBase.sfh"

struct MaterialParameter
{
    float4 _baseColor;
    uint _baseColorTextureIndex;
    uint _normalTextureIndex;
    uint _rmahTextureIndex;
    float _roughnessScale;
    float _metalnessScale;
};

float4 main(float4 position : SV_Position) : SV_TARGET
{
    PrimitiveInfo primitiveInfo = getPrimitiveInfo(position.xy);
    
    uint materialParameterOffset = _materialParameterOffsets.Load(primitiveInfo._materialIndex * UINT32_SIZE_IN_BYTE);
    MaterialParameter materialParameter = _materialParameters.Load<MaterialParameter>(materialParameterOffset);
    Texture2D albedoTexture = getTexture(materialParameter._baseColorTextureIndex);
    Texture2D normalTexture = getTexture(materialParameter._normalTextureIndex);
    Texture2D rmahTexture = getTexture(materialParameter._rmahTextureIndex);
    
    float3 diffuseColor = sampleTextureAnisotropic(albedoTexture, primitiveInfo).rgb;
    float3 normalColor = sampleTextureAnisotropic(normalTexture, primitiveInfo).rgb;
    float3 rmahColor = sampleTextureAnisotropic(rmahTexture, primitiveInfo).rgb;
    
    float3 albedo = materialParameter._baseColor.rgb * diffuseColor;
    
    float3 N = applyTangentSpaceNormalMap(normalColor, primitiveInfo._worldNormal, primitiveInfo._worldTangent);
    //float3 N = primitiveInfo._worldNormal;
    
    const float3 Fdielectric = 0.04;
    float cubeMapMipCount = 11;
    float roughness = rmahColor.r * materialParameter._roughnessScale;
    float metalness = rmahColor.g * materialParameter._metalnessScale;
    float3 V = normalize(_viewInfo._cameraPosition - primitiveInfo._worldPosition);
    float3 R = reflect(-V, N);
    float3 F0 = lerp(Fdielectric, albedo, metalness);
    float NoV = saturate(dot(N, V));
    
    float3 directionalLightColor = float3(0, 0, 0);
    {
        DirectionalLight directionalLight = _directionalLights.Load<DirectionalLight>(0);
        float3 L = -directionalLight._direction;
        float3 H = normalize(V + L);
        float NoL = saturate(dot(N, L));
        float3 radiance = directionalLight._color * directionalLight._intensity;

        // Cook-Torrance BRDF
        float NDF = distributionGGX(N, H, roughness);
        float G = geometrySmith(N, V, L, roughness);
        float3 F = fresnelSchlick(saturate(dot(H, V)), F0);
        
        float3 numerator = NDF * G * F;
        float denominator = 4.0 * NoV * NoL + EPSILON;
        float3 specular = numerator / denominator;
        
        float3 kS = F;
        float3 kD = float3(1.0, 1.0, 1.0) - kS;
        kD *= 1.0 - metalness;

        directionalLightColor += (kD * albedo / PI + specular) * radiance * NoL;
    }
    
    float diffuseIBLScale = _skySphere._diffuseScale;
    float specularIBLScale = _skySphere._specularScale;
    float3 diffuseIBLColor = float3(0, 0, 0);
    float3 specularIBLColor = float3(0, 0, 0);
    {
        float3 F = fresnelSchlickRoughness(NoV, F0, roughness);
        float3 kS = F;
        float3 kD = 1.0 - kS;
        kD *= 1.0 - metalness;
        
        diffuseIBLColor = _skyDiffuse.SampleLevel(_linerSampler, N, 8).rgb * kD * albedo;
        
        Texture2D brdfLutTexture = getTexture(_skySphere._brdfLutTextureIndex);
        float3 specularIrradiance = _skySpecular.SampleLevel(_linerSampler, R, roughness * cubeMapMipCount).rgb;
        float2 specularBRDF = brdfLutTexture.SampleGrad(_anisotropicSampler, float2(NoV, roughness), primitiveInfo._ddx, primitiveInfo._ddy).rg;
        specularIBLColor = specularIrradiance * (F * specularBRDF.x + specularBRDF.y);
    }
    
    //float3 radiance = directionalLightColor + specularIBLColor;
    float3 radiance = directionalLightColor + specularIBLColor * specularIBLScale + diffuseIBLColor * diffuseIBLScale;
    float3 finalColor = radiance;
    //return float4(primitiveInfo._ddy.x, primitiveInfo._ddy.y, 0, 1);
    
    bool doToneMap = true;
    switch (_debugMaterialType._type)
    {
        case DEBUG_MATERIAL_TYPE_NONE:
            {
                break;
            }
        case DEBUG_MATERIAL_TYPE_BASE_COLOR:
            {
                finalColor = albedo;
                doToneMap = false;
                break;
            }
        case DEBUG_MATERIAL_TYPE_NORMAL:
            {
                finalColor = N * 0.5 + 0.5;
                doToneMap = false;
                break;
            }
        case DEBUG_MATERIAL_TYPE_METALIC:
            {
                finalColor = float3(metalness, metalness, metalness);
                doToneMap = false;
                break;
            }
        case DEBUG_MATERIAL_TYPE_ROUGHNESS:
            {
                finalColor = float3(roughness, roughness, roughness);
                doToneMap = false;
                break;
            }
        case DEBUG_MATERIAL_TYPE_DIRECT_LIGHTING:
            {
                finalColor = directionalLightColor;
                break;
            }
        case DEBUG_MATERIAL_TYPE_INDIRECT_LIGHTING:
            {
                finalColor = diffuseIBLColor + specularIBLColor;
                break;
            }
        case DEBUG_MATERIAL_TYPE_INDIRECT_DIFFUSE:
            {
                finalColor = diffuseIBLColor;
                break;
            }
        case DEBUG_MATERIAL_TYPE_INDIRECT_SPECULAR:
            {
                finalColor = specularIBLColor;
                break;
            }
    }
    
    if (doToneMap)
    {
        finalColor = ACESFilm(finalColor);
    }
    return float4(finalColor, 1.0);
}