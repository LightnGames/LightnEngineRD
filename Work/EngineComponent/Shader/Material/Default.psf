#include "ShaderInput.sfh"
#include "../ViewInfo.sfh"
#include "../Def.sfh"
#include "../MeshRenderer/MeshDef.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b0);

ByteAddressBuffer _materialParameters : register(t0);
ByteAddressBuffer _meshes : register(t1);
ByteAddressBuffer _lodMeshes : register(t2);
ByteAddressBuffer _meshInstances : register(t3);
ByteAddressBuffer _meshInstanceLodLevels : register(t4);
ByteAddressBuffer _geometryGlobalOffsets : register(t5);

ByteAddressBuffer _vertexPositions : register(t6);
ByteAddressBuffer _vertexTexcoords : register(t7);
ByteAddressBuffer _vertexIndices : register(t8);

Texture2D<uint2> _triangleAttributes : register(t9);

Texture2D _textures[] : register(t0, space1);
SamplerState _anisotropicSampler : register(s0);

struct MaterialParameter
{
    float4 _baseColor;
    uint _baseColorTextureIndex;
};

float3 heatMap(float unormValue)
{
    float redValue = min(unormValue * 2.0, 1.0);
    float blueValue = max((unormValue - 0.5) * 2.0, 0.0);
    return lerp(float3(1, 0, 0), lerp(float3(0, 1, 0), float3(0, 0, 1), blueValue), redValue);
}

// 32bit uint -> 16bit float2
float2 unpackTexCoords(uint packed)
{
    uint x = (packed.x >> 0) & 0xffff;
    uint y = (packed.x >> 16) & 0xffff;
    float div = UINT16_MAX / 8.0;
    return (float2(x, y) / div) - 4.0;
}

struct PrimitiveInfo
{
    uint _meshInstanceIndex;
    uint _materialParameterOffset;
    float3 _worldPosition;
    float2 _texcoords;
    float2 _ddx;
    float2 _ddy;
};

struct Barycentrics
{
    float3 UVW;
    float3 UVW_dx;
    float3 UVW_dy;
};

/** Calculates perspective correct barycentric coordinates and partial derivatives using screen derivatives. */
Barycentrics CalculateTriangleBarycentrics(float2 PixelClip, float4 PointClip0, float4 PointClip1, float4 PointClip2, float2 ViewInvSize)
{
    Barycentrics Result;

    float3 Pos0 = PointClip0.xyz / PointClip0.w;
    float3 Pos1 = PointClip1.xyz / PointClip1.w;
    float3 Pos2 = PointClip2.xyz / PointClip2.w;

    float3 RcpW = rcp(float3(PointClip0.w, PointClip1.w, PointClip2.w));

    float3 Pos120X = float3(Pos1.x, Pos2.x, Pos0.x);
    float3 Pos120Y = float3(Pos1.y, Pos2.y, Pos0.y);
    float3 Pos201X = float3(Pos2.x, Pos0.x, Pos1.x);
    float3 Pos201Y = float3(Pos2.y, Pos0.y, Pos1.y);

    float3 C_dx = Pos201Y - Pos120Y;
    float3 C_dy = Pos120X - Pos201X;

    float3 C = C_dx * (PixelClip.x - Pos120X) + C_dy * (PixelClip.y - Pos120Y); // Evaluate the 3 edge functions
    float3 G = C * RcpW;

    float H = dot(C, RcpW);
    float RcpH = rcp(H);

	// UVW = C * RcpW / dot(C, RcpW)
    Result.UVW = G * RcpH;

	// Texture coordinate derivatives:
	// UVW = G / H where G = C * RcpW and H = dot(C, RcpW)
	// UVW' = (G' * H - G * H') / H^2
	// float2 TexCoordDX = UVW_dx.y * TexCoord10 + UVW_dx.z * TexCoord20;
	// float2 TexCoordDY = UVW_dy.y * TexCoord10 + UVW_dy.z * TexCoord20;
    float3 G_dx = C_dx * RcpW;
    float3 G_dy = C_dy * RcpW;

    float H_dx = dot(C_dx, RcpW);
    float H_dy = dot(C_dy, RcpW);

    Result.UVW_dx = (G_dx * H - G * H_dx) * (RcpH * RcpH) * (2.0f * ViewInvSize.x);
    Result.UVW_dy = (G_dy * H - G * H_dy) * (RcpH * RcpH) * (-2.0f * ViewInvSize.y);

    return Result;
}

PrimitiveInfo getPrimitiveInfo(float2 pixelPosition)
{
    uint2 triangleAttributes = _triangleAttributes[pixelPosition];
    
    uint meshInstanceIndex = triangleAttributes.y & 0x0000ffff;
    uint materialParameterOffset = (triangleAttributes.y >> 18) & 0x0000ffff;
    uint currentLodLevel = _meshInstanceLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE);
    MeshInstance meshInstance = getMeshInstance(_meshInstances, meshInstanceIndex);
    Mesh mesh = getMesh(_meshes, meshInstance._meshIndex);
    
    uint lodMeshIndex = mesh._lodMeshOffset + currentLodLevel;
    LodMesh lodMesh = getLodMesh(_lodMeshes, lodMeshIndex);
    GeometryGlobalOffsetInfo geometryGlobalOffsetInfo = getGeometryGlobalOffsetInfo(_geometryGlobalOffsets, lodMeshIndex);
    
    uint3 primitiveIndices = uint3(
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 0) + geometryGlobalOffsetInfo._vertexOffset,
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 1) + geometryGlobalOffsetInfo._vertexOffset,
            loadUint(_vertexIndices, triangleAttributes.x * 3 + 2) + geometryGlobalOffsetInfo._vertexOffset
    );
    const float3 PointLocal0 = loadFloat3(_vertexPositions, primitiveIndices.x);
    const float3 PointLocal1 = loadFloat3(_vertexPositions, primitiveIndices.y);
    const float3 PointLocal2 = loadFloat3(_vertexPositions, primitiveIndices.z);
    
    const float2 texcoords0 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.x));
    const float2 texcoords1 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.y));
    const float2 texcoords2 = unpackTexCoords(loadUint(_vertexTexcoords, primitiveIndices.z));
    
    float4x3 matrixWorld = meshInstance._worldMatrix;
    float3 pointToWorld0 = mul(float4(PointLocal0, 1), matrixWorld);
    float3 pointToWorld1 = mul(float4(PointLocal1, 1), matrixWorld);
    float3 pointToWorld2 = mul(float4(PointLocal2, 1), matrixWorld);
    
    const float4 PointClip0 = mul(float4(pointToWorld0, 1), _viewInfo._matrixViewProj);
    const float4 PointClip1 = mul(float4(pointToWorld1, 1), _viewInfo._matrixViewProj);
    const float4 PointClip2 = mul(float4(pointToWorld2, 1), _viewInfo._matrixViewProj);
    
    float2 viewInvSize = float2(1.0, 1.0) / float2(_viewInfo._viewPortSize);
    const float2 PixelClip = (pixelPosition + 0.5) * viewInvSize * float2(2, -2) + float2(-1, 1);
    
    // Calculate perspective correct barycentric coordinates with screen derivatives
    const Barycentrics Barycentrics = CalculateTriangleBarycentrics(PixelClip, PointClip0, PointClip1, PointClip2, viewInvSize);
    
    float3 worldPosition = Barycentrics.UVW.x * pointToWorld0 + Barycentrics.UVW.y * pointToWorld1 + Barycentrics.UVW.z * pointToWorld2;
    float2 texcoords = Barycentrics.UVW.x * texcoords0 + Barycentrics.UVW.y * texcoords1 + Barycentrics.UVW.z * texcoords2;
    
    float2 TexCoord10 = texcoords1 - texcoords0;
    float2 TexCoord20 = texcoords2 - texcoords0;

    float2 TexCoord = texcoords0 + Barycentrics.UVW.y * TexCoord10 + Barycentrics.UVW.z * TexCoord20;
    float2 ddx = Barycentrics.UVW_dx.y * TexCoord10 + Barycentrics.UVW_dx.z * TexCoord20;
    float2 ddy = Barycentrics.UVW_dy.y * TexCoord10 + Barycentrics.UVW_dy.z * TexCoord20;
    
    PrimitiveInfo primitiveInfo;
    primitiveInfo._meshInstanceIndex = meshInstanceIndex;
    primitiveInfo._materialParameterOffset = materialParameterOffset * UINT32_SIZE_IN_BYTE;
    primitiveInfo._worldPosition = worldPosition;
    primitiveInfo._texcoords = texcoords;
    primitiveInfo._ddx = ddx;
    primitiveInfo._ddy = ddy;
    return primitiveInfo;
}

float4 main(float4 position : SV_Position) : SV_TARGET
{
    PrimitiveInfo primitiveInfo = getPrimitiveInfo(position.xy);
    
    MaterialParameter materialParameter = _materialParameters.Load<MaterialParameter>(primitiveInfo._materialParameterOffset);
    Texture2D albedoTexture = _textures[NonUniformResourceIndex(materialParameter._baseColorTextureIndex)];
    
    float3 baseColor = albedoTexture.SampleGrad(_anisotropicSampler, primitiveInfo._texcoords, primitiveInfo._ddx, primitiveInfo._ddy).rgb;

    //float4 baseColor = _textures[NonUniformResourceIndex(materialParameter._baseColorTextureIndex)].Sample(_anisotropicSampler, input._texcoord);
    //float screenPersentages = float(_meshInstanceScreenPersentages.Load(input._meshInstanceIndex * UINT32_SIZE_IN_BYTE)) / float(UINT16_MAX);
    //float screenPersentages = float(_meshInstanceLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE)) / float(4);
    //float screenPersentages = float(_materialScreenPersentages.Load(input._materialIndex * UINT32_SIZE_IN_BYTE)) / float(UINT16_MAX);
    //return float4(input._texcoord, 0, 1);
    //return float4(heatMap(1.0 - screenPersentages), 1.0);
    return materialParameter._baseColor * float4(baseColor, 1.0);
}