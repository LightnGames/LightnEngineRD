#include "mesh_culling_frustum_template.sfh"

RWByteAddressBuffer _cullingResult : register(u3);
Texture2D<float> _hizTextures[] : register(t8);

[numthreads(128, 1, 1)]
void main(in uint3 groupID : SV_GroupID, in uint3 groupThreadID : SV_GroupThreadID)
{
    uint meshInstanceIndex = getMeshInstanceIndex(groupID.x, groupThreadID.x);
    if (!isTested(meshInstanceIndex))
    {
        return;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    Mesh mesh = getMesh(meshInstance);
    uint lodLevel = getCurrentLodLevel(meshInstanceIndex);
	
    LodMesh lodMesh = getLodMesh(mesh, lodLevel);
    uint subMeshCount = lodMesh._subMeshCount;
    
    ViewInfo viewInfo = _viewInfo;
    float3 boundsMin = meshInstance._aabbMin;
    float3 boundsMax = meshInstance._aabbMax;
    bool inFrustum = doFrustumCulling(boundsMin, boundsMax, viewInfo);
    if (inFrustum)
    {
        uint hizLevel = 0;
        uint2 coords = uint2(0, 0);
        uint2 sampleCount = uint2(0, 0);
        uint2 hizSize = uint2(0, 0);
        bool isTestedOcclusion = computeHizLevelAndCoords(boundsMin, boundsMax, viewInfo, hizLevel, coords, sampleCount, hizSize);
        
        uint currentCount = 0;
        bool isPassed = true;
        if (isTestedOcclusion)
        {
            float hizDepthValue = sampleHiz(hizSize, sampleCount, coords, _hizTextures[hizLevel]);
            isPassed = isOcclusion(hizDepthValue, boundsMin, boundsMax, viewInfo);
            if (isPassed)
            {
                _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_MESH_INSTANCE_COUNT_OFFSET, 1, currentCount);
                _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_SUBMESH_INSTANCE_COUNT_OFFSET, subMeshCount, currentCount);
            }
        
            _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_MESH_INSTANCE_COUNT_OFFSET, 1, currentCount);
            _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_SUBMESH_INSTANCE_COUNT_OFFSET, subMeshCount, currentCount);
        }
        
        if (isPassed)
        {
            addIndirectArgument(meshInstanceIndex);
        }
        
        _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_MESH_INSTANCE_COUNT_OFFSET, 1, currentCount);
        _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_SUBMESH_INSTANCE_COUNT_OFFSET, subMeshCount, currentCount);
    }
       
    
    uint currentCount = 0;
    _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_MESH_INSTANCE_COUNT_OFFSET, 1, currentCount);
    _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_SUBMESH_INSTANCE_COUNT_OFFSET, subMeshCount, currentCount);
}