#include "../constant_buffer.sfh"
#include "../shaderInput.sfh"
#include "../gpu_driven.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b0);
#if UBER_PRIMITIVE_INSTANCING
ConstantBuffer<MeshShaderIndirectArgument> _primitiveInstancingConstant : register(b2);
#endif

StructuredBuffer<CustomParameters> _customParameters : register(t0);
StructuredBuffer<Mesh> _meshes : register(t1);
StructuredBuffer<LodMesh> _lodMeshes : register(t2);
StructuredBuffer<SubMesh> _subMeshes : register(t3);
StructuredBuffer<Meshlet> _meshlets : register(t4);

StructuredBuffer<MeshInstance> _meshInstances : register(t5);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t6);
StructuredBuffer<SubMeshInstance> _subMeshInstances : register(t7);

StructuredBuffer<MeshletInstanceInfo> _meshletInstanceInfos : register(t9);
StructuredBuffer<uint> _vertexIndices : register(t10);
StructuredBuffer<uint> _primitives : register(t11);
StructuredBuffer<float3> _vertexPositions : register(t12);
StructuredBuffer<uint> _vertexNormalTangents : register(t13);
StructuredBuffer<uint> _vertexTexcoords : register(t14);

[NumThreads(128, 1, 1)]
[OutputTopology("triangle")]
void main(
	uint gid : SV_GroupID,
	uint gtid : SV_GroupThreadID,
	uint dtid : SV_DispatchThreadID,
#if UBER_DEFAULT
    in payload PayloadStruct meshPayload,
#endif
    out indices uint3 tris[126],
    out vertices VertexOut verts[64]
)
{
    if (gtid >= 126) {
        return;
    }
#if UBER_DEFAULT
    uint vertexCount = meshPayload._meshletVertexCounts[gid];
    uint primitiveCount = meshPayload._meshletPrimitiveCounts[gid]; 
    uint instanceCount = 1;
    uint instanceOffset = gid;
    if(meshPayload._unpackedCount > 0 && gid >= meshPayload._unpackedOffset) {
        uint instancePerGroup = min(64 / vertexCount, 126 / primitiveCount);
        uint offset = (gid - meshPayload._unpackedOffset) * instancePerGroup;
        instanceCount = min(meshPayload._unpackedCount - offset, instancePerGroup);
        instanceOffset = meshPayload._unpackedOffset + offset;
    }

    uint totalVertexCount = vertexCount * instanceCount;
    uint totalPrimitiveCount = primitiveCount * instanceCount;
    SetMeshOutputCounts(totalVertexCount, totalPrimitiveCount);

    uint vertexInstanceIndex = gtid / vertexCount;
    uint primitiveInstanceIndex = gtid / primitiveCount;
    if(gtid < totalPrimitiveCount){
        uint primitiveLocalGtid = gtid % primitiveCount;
        uint primitiveMeshletOffset = instanceOffset + primitiveInstanceIndex;
        uint primitiveOffset = meshPayload._primitiveOffset[instanceOffset];
        uint packedIndex = _primitives[primitiveOffset + primitiveLocalGtid];
        uint3 unpackedIndex = uint3(packedIndex & 0xff, (packedIndex >> 8) & 0xff, (packedIndex >> 16) & 0xff);
        uint indexOffset = primitiveInstanceIndex * vertexCount;
        tris[gtid] = unpackedIndex + uint3(indexOffset, indexOffset, indexOffset);
    }

    if(gtid < totalVertexCount){
        uint vertexLocalGtid = gtid % vertexCount;
        uint vertexMeshletOffset = instanceOffset + vertexInstanceIndex;
        uint meshInstanceIndex = meshPayload._meshInstanceIndices[vertexMeshletOffset];
        uint vertexLocalOffset = meshPayload._vertexOffset[vertexMeshletOffset];
        uint vertexIndexOffset = meshPayload._vertexIndexOffset[vertexMeshletOffset];
        uint materialIndex = meshPayload._materialIndex[vertexMeshletOffset];
        MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
        uint vertexIndex = _vertexIndices[vertexIndexOffset + vertexLocalGtid];
        uint vertexOffset = vertexLocalOffset + vertexIndex;
        float3 positionVertex = _vertexPositions[vertexOffset];
        float4 worldPos = mul(float4(positionVertex, 1), meshInstance._matrixWorld);
        
        VertexOut vertexOut;
        vertexOut._position = mul(worldPos, _viewInfo._matrixViewProj);
        vertexOut._positionNdc = worldPos;
        vertexOut._texcoord = unpackTexCoords(_vertexTexcoords[vertexOffset]);
        vertexOut._meshletIndex = gid;
        vertexOut._materialIndex = materialIndex;
        vertexOut._meshInstanceIndex = meshInstanceIndex;
        verts[gtid] = vertexOut;
    }
#endif

#if UBER_PRIMITIVE_INSTANCING
    IndirectArgumentConstant indirectArgumentConstant = _primitiveInstancingConstant._constant;
    uint meshletLocalIndex = min(gid / indirectArgumentConstant._instanceCount, indirectArgumentConstant._meshletCount - 1);
    uint meshletIndex = _primitiveInstancingConstant._meshletOffset;
    Meshlet meshlet = _meshlets[meshletIndex + meshletLocalIndex];
    uint vertexCount = meshlet._vertexCount;
    uint primitiveCount = meshlet._primitiveCount;

    uint instanceOffset = gid % indirectArgumentConstant._instanceCount;
    uint meshletInfoLocalOffset = instanceOffset;
    uint instanceCount = 1;
    if(meshletLocalIndex == indirectArgumentConstant._meshletCount - 1) {
        uint instanceCountPerGroup = min(64 / vertexCount, 126 / primitiveCount);
        meshletInfoLocalOffset = instanceOffset * instanceCountPerGroup;
        instanceCount = min(indirectArgumentConstant._instanceCount - meshletInfoLocalOffset, instanceCountPerGroup);
    }
    
    uint globalInstanceIndex = indirectArgumentConstant._meshletInstanceInfoOffset;
    uint totalVertexCount = vertexCount * instanceCount;
    uint totalPrimitiveCount = primitiveCount * instanceCount;
    SetMeshOutputCounts(totalVertexCount, totalPrimitiveCount);

    if(gtid < totalPrimitiveCount) {
        uint infoOffset = globalInstanceIndex + meshletInfoLocalOffset;
        uint primitiveInstanceIndex = gtid / primitiveCount;
        MeshletInstanceInfo primitiveMeshletInstanceInfo = _meshletInstanceInfos[infoOffset + primitiveInstanceIndex]; // TODO:　メモリアクセス改善
        uint primitiveGtid = gtid % primitiveCount;
        uint primitiveOffset = primitiveMeshletInstanceInfo._primitiveOffset;
        uint primitiveIndex = meshlet._primitiveOffset + primitiveGtid;
        uint packedIndex = _primitives[primitiveOffset + primitiveIndex];
        uint3 unpackedIndex = uint3(packedIndex & 0xff, (packedIndex >> 8) & 0xff, (packedIndex >> 16) & 0xff);
        uint indexOffset = vertexCount * primitiveInstanceIndex;
        unpackedIndex += uint3(indexOffset, indexOffset, indexOffset);
        tris[gtid] = unpackedIndex;
    }

    if(gtid < totalVertexCount) {
        uint infoOffset = globalInstanceIndex + meshletInfoLocalOffset;
        uint vertexInstanceIndex = gtid / vertexCount;
        MeshletInstanceInfo vertexMeshletInstanceInfo = _meshletInstanceInfos[infoOffset + vertexInstanceIndex];
        uint vertexGtid = gtid % vertexCount;
        uint meshInstanceIndex = vertexMeshletInstanceInfo._meshInstanceIndex;
        uint materialIndex = vertexMeshletInstanceInfo._materialIndex;
        uint vertexLocalOffset = vertexMeshletInstanceInfo._vertexOffset;
        uint vertexIndexOffset = vertexMeshletInstanceInfo._vertexIndexOffset;
        MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    
        uint vertexLocalIndex = meshlet._vertexOffset + vertexGtid;
        uint vertexIndex = _vertexIndices[vertexIndexOffset + vertexLocalIndex];
        uint vertexOffset = vertexLocalOffset + vertexIndex;
        float3 positionVertex = _vertexPositions[vertexOffset];
        float4 worldPos = mul(float4(positionVertex, 1), meshInstance._matrixWorld);
        
        VertexOut vertexOut;
        vertexOut._position = mul(worldPos, _viewInfo._matrixViewProj);
        vertexOut._positionNdc = worldPos;
        vertexOut._texcoord = unpackTexCoords(_vertexTexcoords[vertexOffset]);
        vertexOut._meshletIndex = meshletIndex;
        vertexOut._materialIndex = materialIndex;
        vertexOut._meshInstanceIndex = meshInstanceIndex;
        verts[gtid] = vertexOut;
    }
#endif
}
