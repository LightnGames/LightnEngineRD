#include "../constant_buffer.sfh"
#include "../shaderInput.sfh"
#include "../gpu_driven.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b0);

StructuredBuffer<CustomParameters> _customParameters : register(t0);
StructuredBuffer<Mesh> _meshes : register(t1);
StructuredBuffer<LodMesh> _lodMeshes : register(t2);
StructuredBuffer<SubMesh> _subMeshes : register(t3);
StructuredBuffer<Meshlet> _meshlets : register(t4);

StructuredBuffer<MeshInstance> _meshInstances : register(t5);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t6);
StructuredBuffer<SubMeshInstance> _subMeshInstances : register(t7);

StructuredBuffer<uint> _vertexIndices : register(t9);
StructuredBuffer<uint> _primitives : register(t10);
StructuredBuffer<float3> _vertexPositions : register(t11);
StructuredBuffer<uint> _vertexNormalTangents : register(t12);
StructuredBuffer<uint> _vertexTexcoords : register(t13);

ByteAddressBuffer _currentLodLevels : register(t15);

struct DebugPrimitive {
	uint3 _dispatchAS;
	uint3 _dispatchMS;
	uint _meshletIndex;
	uint2 _setMeshOutputCount;
	uint _checkSum;
};
RWStructuredBuffer<DebugPrimitive> _debugOutputPrimitives : register(u0);

[NumThreads(128, 1, 1)]
[OutputTopology("triangle")]
void main(
    uint gtid : SV_GroupThreadID,
    uint3 gid : SV_GroupID,
    in payload PayloadStruct meshPayload,
    out indices uint3 tris[126],
    out vertices VertexOut verts[64]
){
    uint meshletLocalIndex = gid.x;
    uint meshInstanceIndex = meshPayload._meshInstanceIndices[meshletLocalIndex];
    uint meshletIndex = meshPayload._meshletIndices[meshletLocalIndex];
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    Meshlet meshlet = _meshlets[meshletIndex];
    Mesh mesh = _meshes[meshInstance._meshIndex];

    uint vertexCount = meshlet._vertexCount;
    uint primitiveCount = meshlet._primitiveCount;
    SetMeshOutputCounts(vertexCount, primitiveCount);

	uint asOffset = debugPrimitive._dispatchAS.x * 32 + debugPrimitive._dispatchAS.y;
	uint msOffset = debugPrimitive._dispatchMS.x * 128 + debugPrimitive._dispatchMS.y;
	uint debugOffset = asOffset * 128 + msOffset;

	DebugPrimitive debugPrimitive;
	debugPrimitive._dispatchAS;
	debugPrimitive._dispatchMS = uint3(gid.x, gtid, 0);
	debugPrimitive._meshletIndex = meshletIndex;
	debugPrimitive._setMeshOutputCount = uint2(vertexCount, primitiveCount);
	debugPrimitive._checkSum = debugOffset;
	_debugOutputPrimitives[debugOffset] = debugPrimitive;

    uint threadIndex = gtid;
    if(threadIndex < primitiveCount){
        uint primitiveIndex = meshlet._primitiveOffset + threadIndex;
        uint packedIndex = _primitives[meshPayload._primitiveOffset[meshletLocalIndex] + primitiveIndex];
        tris[threadIndex] = uint3(packedIndex & 0xff, (packedIndex >> 8) & 0xff, (packedIndex >> 16) & 0xff);
    }

    if(threadIndex < vertexCount){
        uint vertexLocalIndex = meshlet._vertexOffset + threadIndex;
        uint vertexIndex = _vertexIndices[meshPayload._vertexIndexOffset[meshletLocalIndex] + vertexLocalIndex];
        uint vertexOffset = meshPayload._vertexOffset[meshletLocalIndex] + vertexIndex;
        float3 positionVertex = _vertexPositions[vertexOffset];
        float4 worldPos = mul(float4(positionVertex, 1), meshInstance._matrixWorld);

        uint currentLodLevel = _currentLodLevels.Load(meshInstanceIndex * 4);
        
        VertexOut vertexOut;
        vertexOut._position = mul(worldPos, _viewInfo._matrixViewProj);
        vertexOut._positionNdc = worldPos;
        vertexOut._texcoord = unpackTexCoords(_vertexTexcoords[vertexOffset]);
        vertexOut._meshletIndex = meshletIndex;
        vertexOut._materialIndex = meshPayload._materialIndex[meshletLocalIndex];

        vertexOut._lodLevel = 0.0;
        if(mesh._lodMeshCount > 1){
            vertexOut._lodLevel = currentLodLevel / (float)(mesh._lodMeshCount - 1);
        }

        verts[threadIndex] = vertexOut;
    }
}
