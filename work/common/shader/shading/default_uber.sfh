#include "../shaderInput.sfh"
#include "../constant_buffer.sfh"
#include "../gpu_driven.sfh"
#include "../util.sfh"

#define ENABLE_SDF 1

static const uint GLOBAL_SDF_LAYER_LEVEL = 4;
static const float SDF_GLOBAL_CELL_HALF_SIZE = 25.6;
static const float SDF_GLOBAL_CELL_SIZE = 6.4f;
static const int SDF_GLOBAL_WIDTH = 8;

ConstantBuffer<ViewInfo> _viewInfo : register(b0);
StructuredBuffer<CustomParameters> _customParameters : register(t0);
StructuredBuffer<MeshInstance> _meshInstances : register(t6);
Texture2D _textures[128] : register(t38);
SamplerState _sampler : register(s0);

#if VISIBILITY_BUFFER_PASS
Texture2D<uint2> _triangleAttributes : register(t29);
StructuredBuffer<uint> _primitiveIndices : register(t30);
StructuredBuffer<float3> _vertexPositions : register(t31);
StructuredBuffer<uint> _vertexNormalTangents : register(t32);
StructuredBuffer<uint> _vertexTexcoords : register(t33);
StructuredBuffer<float4x3> _meshInstanceWorldMatrics : register(t34);
StructuredBuffer<Mesh> _meshes : register(t35);
StructuredBuffer<LodMesh> _lodMeshes : register(t36);
ByteAddressBuffer _currentLodLevels : register(t37);
#endif

#if ENABLE_SDF
StructuredBuffer<float4x3> _meshInstanceBoundsInvMatrices : register(t166);
StructuredBuffer<uint> _sdfMeshInstanceIndexOffsets[GLOBAL_SDF_LAYER_LEVEL] : register(t167);
StructuredBuffer<uint> _sdfMeshInstanceIndices[GLOBAL_SDF_LAYER_LEVEL] : register(t171);
StructuredBuffer<uint> _sdfMeshInstanceCounts[GLOBAL_SDF_LAYER_LEVEL] : register(t175);
Texture3D _sdfTextures[] : register(t179);

SamplerState _linerSampler : register(s1);

// position が AABB の内側にあるか判定します
bool isInsideAABB(float3 position, float halfExtent)
{
    return abs(position.x) <= halfExtent &&
            abs(position.y) <= halfExtent &&
            abs(position.z) <= halfExtent;
}

// [ x, y, z ] のインデックスから 1次元配列にアクセスするためのインデックスを計算します
uint getSdfIndexFromId(int3 id)
{
    uint depthOffset = id.z * SDF_GLOBAL_WIDTH * SDF_GLOBAL_WIDTH;
    uint heightOffset = id.y * SDF_GLOBAL_WIDTH;
    uint widthOffset = id.x;
    return depthOffset + heightOffset + widthOffset;
}

// SDF の 3D テクスチャをサンプルします
float sampleSdf(uint textureIndex, float3 localPosition)
{
    return _sdfTextures[textureIndex].Sample(_linerSampler, localPosition + float3(0.5, 0.5, 0.5)).x;
}

// SDF をレイマーチして交差するか取得します
bool intersectSdf(uint sdfIndex, float3 position, float3 rayDirection)
{
    float invStepScale = max(1.0 / length(rayDirection), 0.01);
    int SAMPLE_COUNT_MAX = 16;
    float BIAS = 0.01;
    float minStepSize = 1.0f / (4 * SAMPLE_COUNT_MAX);
    bool isHit = false;
    float3 rayStartPosition = position;
    float3 currentRayOrigin = rayStartPosition;
    float rayDistance = invStepScale * 0.05;
    
    [loop]
    for (int i = 0; i < SAMPLE_COUNT_MAX; ++i)
    {
        currentRayOrigin = rayStartPosition + rayDistance * rayDirection;
        if (!isInsideAABB(currentRayOrigin, 0.5))
        {
            break;
        }
        
        float distance = sampleSdf(sdfIndex, currentRayOrigin);      
        float stepDistance = max(distance, minStepSize);
        rayDistance += stepDistance;
        
        if (distance < BIAS)
        {
            return true;
        }
    }
    return false;
}

// レイが AABB と交差するか取得します
bool intersectRayAABB(float3 ro, float3 rd, float3 pmin, float3 pmax, out float2 distances, out float3 uv3)
{
    float3 tmin = (pmin - ro) / rd;
    float3 tmax = (pmax - ro) / rd;
    float3 sc = min(tmin, tmax);
    float3 sf = max(tmin, tmax);
    float t0 = max(max(sc.x, sc.y), sc.z);
    float t1 = min(min(sf.x, sf.y), sf.z);

    distances = float2(t0, t1);
    
    if (isInsideAABB(ro, 0.5))
    {
        uv3 = ro;
        return true;
    }
    
    if (t0 < 0)
    {
        return false;
    }
    
    // Texture coordinates
    float3 uv = ro + t0 * rd;
    if (isInsideAABB(uv, 0.5 + EPSILON))
    {
        uv3 = uv;
        return true;
    }
    
    return false;
}

// ワールド座標から GDF レイヤーレベルを取得します
uint getGlobalDistanceFieldLayerLevel(float3 worldPosition)
{
    int3 position = int3(abs(worldPosition) / SDF_GLOBAL_CELL_HALF_SIZE);
    int3 levels = firstbithigh(position) + 1;
    return max(levels.x, max(levels.y, levels.z));
}

// Distance field を用いたシャドウ
bool raytraceShadow(float3 rayOrigin, float3 lightDirection)
{
    float3 invLightDirection = -lightDirection;
    uint WORLD_CELL_LOOP_COUNT_MAX = 16;
    float cellDistance = 0.15;
    uint3 prevWorldPosition = uint3(0, 0, 0);
    
    // セルごとにグリッドを走査
    [loop]
    for (uint cellItr = 0; cellItr < WORLD_CELL_LOOP_COUNT_MAX; ++cellItr)
    {
        float3 worldPosition = rayOrigin + cellDistance * invLightDirection;
        uint minLayerLevel = getGlobalDistanceFieldLayerLevel(worldPosition);
        if (minLayerLevel >= GLOBAL_SDF_LAYER_LEVEL - 1)
        {
            break;
        }
        
        // 走査するレイヤーの最大レベルを計算
        uint3 currentWorldPosition = abs(int3(floor(worldPosition / SDF_GLOBAL_CELL_SIZE)));
        uint3 diff = currentWorldPosition ^ prevWorldPosition;
        int3 worldPositionDiff = firstbithigh(int3(diff)) + 1;
        uint topLayerLevel = min(max(worldPositionDiff.x, max(worldPositionDiff.y, worldPositionDiff.z)), GLOBAL_SDF_LAYER_LEVEL);
        
        // 最初のセルは最上位レイヤーまで捜査
        if (cellItr == 0)
        {
            topLayerLevel = GLOBAL_SDF_LAYER_LEVEL;

        }
        prevWorldPosition = currentWorldPosition;
        
        // 最小〜最大レイヤーレベルまでグリッド内のメッシュインスタンスを走査
        [loop]
        for (uint layerLevel = minLayerLevel; layerLevel < topLayerLevel; ++layerLevel)
        {
            // 検索するレイヤーのグリッドIDを取得
            float cellSize = (1 << layerLevel) * SDF_GLOBAL_CELL_SIZE;
            float layerExtent = float(SDF_GLOBAL_WIDTH) * cellSize * 0.5;
            float3 layerCenterOffset = float3(layerExtent, layerExtent, layerExtent);
            int3 sdfGridId = int3((worldPosition + layerCenterOffset) / cellSize);
            uint sdfGridIndex = getSdfIndexFromId(sdfGridId);
            
            // グリッド内のメッシュインスタンスバウンディング OBB にレイがヒットするかチェック
            uint sdfInstanceCount = _sdfMeshInstanceCounts[NonUniformResourceIndex(layerLevel)][sdfGridIndex];
            uint sdfInstanceStartOffset = _sdfMeshInstanceIndexOffsets[NonUniformResourceIndex(layerLevel)][sdfGridIndex];
            [loop]
            for (int i = 0; i < sdfInstanceCount; ++i)
            {
                uint sdfMeshInstanceIndex = _sdfMeshInstanceIndices[NonUniformResourceIndex(layerLevel)][sdfInstanceStartOffset + i];
                float4x3 invBoundsMatrix = _meshInstanceBoundsInvMatrices[sdfMeshInstanceIndex];
                float3 position = mul(float4(worldPosition, 1), invBoundsMatrix).xyz;
                float3 rayDirection = mul(invLightDirection, (float3x3) invBoundsMatrix);
                float2 distances;
                float3 uv3;
                bool intersectBounds = intersectRayAABB(position, rayDirection, float3(-0.5, -0.5, -0.5), float3(0.5, 0.5, 0.5), distances, uv3);
                if (intersectBounds)
                {
                    // バウンディングOBBにヒットした場合、メッシュインスタンスに対してレイマーチする
                    MeshInstance meshInstance = _meshInstances[sdfMeshInstanceIndex];
                    if (intersectSdf(meshInstance._meshIndex, uv3, rayDirection))
                    {
                        return true;
                    }
                }
            }
        }
        
        // レイがいずれもヒットしない場合、cellDistance を次のグリッドを示す距離にする
        float cellSize = (1 << minLayerLevel) * SDF_GLOBAL_CELL_SIZE;
        float3 halfCellSize = float3(cellSize, cellSize, cellSize) / 2.0;
        float3 cellCenter = floor(worldPosition / cellSize) * cellSize + halfCellSize;
        float2 distances;
        float3 uv3;
        intersectRayAABB(worldPosition, invLightDirection, cellCenter - halfCellSize, cellCenter + halfCellSize, distances, uv3);
        
        // 現在のグリッドAABBの終端までの距離を加算する
        cellDistance += distances.y + EPSILON;
    }
    
    return false;
}
#endif

#if VISIBILITY_BUFFER_PASS
struct Barycentrics
{
    float3 UVW;
    float3 UVW_dx;
    float3 UVW_dy;
};

/** Calculates perspective correct barycentric coordinates and partial derivatives using screen derivatives. */
Barycentrics CalculateTriangleBarycentrics(float2 PixelClip, float4 PointClip0, float4 PointClip1, float4 PointClip2, float2 ViewInvSize)
{
    Barycentrics Result;

    float3 Pos0 = PointClip0.xyz / PointClip0.w;
    float3 Pos1 = PointClip1.xyz / PointClip1.w;
    float3 Pos2 = PointClip2.xyz / PointClip2.w;

    float3 RcpW = rcp(float3(PointClip0.w, PointClip1.w, PointClip2.w));

    float3 Pos120X = float3(Pos1.x, Pos2.x, Pos0.x);
    float3 Pos120Y = float3(Pos1.y, Pos2.y, Pos0.y);
    float3 Pos201X = float3(Pos2.x, Pos0.x, Pos1.x);
    float3 Pos201Y = float3(Pos2.y, Pos0.y, Pos1.y);

    float3 C_dx = Pos201Y - Pos120Y;
    float3 C_dy = Pos120X - Pos201X;

    float3 C = C_dx * (PixelClip.x - Pos120X) + C_dy * (PixelClip.y - Pos120Y); // Evaluate the 3 edge functions
    float3 G = C * RcpW;

    float H = dot(C, RcpW);
    float RcpH = rcp(H);

	// UVW = C * RcpW / dot(C, RcpW)
    Result.UVW = G * RcpH;

	// Texture coordinate derivatives:
	// UVW = G / H where G = C * RcpW and H = dot(C, RcpW)
	// UVW' = (G' * H - G * H') / H^2
	// float2 TexCoordDX = UVW_dx.y * TexCoord10 + UVW_dx.z * TexCoord20;
	// float2 TexCoordDY = UVW_dy.y * TexCoord10 + UVW_dy.z * TexCoord20;
    float3 G_dx = C_dx * RcpW;
    float3 G_dy = C_dy * RcpW;

    float H_dx = dot(C_dx, RcpW);
    float H_dy = dot(C_dy, RcpW);

    Result.UVW_dx = (G_dx * H - G * H_dx) * (RcpH * RcpH) * (2.0f * ViewInvSize.x);
    Result.UVW_dy = (G_dy * H - G * H_dy) * (RcpH * RcpH) * (-2.0f * ViewInvSize.y);

    return Result;
}

float4 main(float4 _position : SV_Position) : SV_TARGET
{
    uint2 pixelPosition = _position.xy;
    uint2 triangleAttributes = _triangleAttributes[pixelPosition];
    
    uint meshInstanceIndex = triangleAttributes.y & 0x0000ffff;
    uint materialIndex = (triangleAttributes.y >> 18) & 0x0000ffff;
    uint currentLodLevel = _currentLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE);
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    Mesh mesh = _meshes[meshInstance._meshIndex];
    LodMesh lodMesh = _lodMeshes[mesh._lodMeshOffset + currentLodLevel];
    
    uint3 primitiveIndices = uint3(
            _primitiveIndices[triangleAttributes.x * 3] + lodMesh._vertexOffset,
            _primitiveIndices[triangleAttributes.x * 3 + 1] + lodMesh._vertexOffset,
            _primitiveIndices[triangleAttributes.x * 3 + 2] + lodMesh._vertexOffset
    );
    const float3 PointLocal0 = _vertexPositions[primitiveIndices.x];
    const float3 PointLocal1 = _vertexPositions[primitiveIndices.y];
    const float3 PointLocal2 = _vertexPositions[primitiveIndices.z];
    
    const float2 texcoords0 = unpackTexCoords(_vertexTexcoords[primitiveIndices.x]);
    const float2 texcoords1 = unpackTexCoords(_vertexTexcoords[primitiveIndices.y]);
    const float2 texcoords2 = unpackTexCoords(_vertexTexcoords[primitiveIndices.z]);
    
    float4x3 matrixWorld = _meshInstanceWorldMatrics[meshInstanceIndex];
    float3 pointToWorld0 = mul(float4(PointLocal0, 1), matrixWorld);
    float3 pointToWorld1 = mul(float4(PointLocal1, 1), matrixWorld);
    float3 pointToWorld2 = mul(float4(PointLocal2, 1), matrixWorld);
    
    const float4 PointClip0 = mul(float4(pointToWorld0, 1), _viewInfo._matrixViewProj);
    const float4 PointClip1 = mul(float4(pointToWorld1, 1), _viewInfo._matrixViewProj);
    const float4 PointClip2 = mul(float4(pointToWorld2, 1), _viewInfo._matrixViewProj);
    
    float2 viewInvSize = float2(1.0, 1.0) / float2(_viewInfo._viewPortSize);
    const float2 PixelClip = (pixelPosition + 0.5) * viewInvSize * float2(2, -2) + float2(-1, 1);
    
    // Calculate perspective correct barycentric coordinates with screen derivatives
    const Barycentrics Barycentrics = CalculateTriangleBarycentrics(PixelClip, PointClip0, PointClip1, PointClip2, viewInvSize);
    
    float3 worldPosition = Barycentrics.UVW.x * pointToWorld0 + Barycentrics.UVW.y * pointToWorld1 + Barycentrics.UVW.z * pointToWorld2;
    float2 texcoords = Barycentrics.UVW.x * texcoords0 + Barycentrics.UVW.y * texcoords1 + Barycentrics.UVW.z * texcoords2;
    
    float2 TexCoord10 = texcoords1 - texcoords0;
    float2 TexCoord20 = texcoords2 - texcoords0;

    float2 TexCoord = texcoords0 + Barycentrics.UVW.y * TexCoord10 + Barycentrics.UVW.z * TexCoord20;
    float2 ddx = Barycentrics.UVW_dx.y * TexCoord10 + Barycentrics.UVW_dx.z * TexCoord20;
    float2 ddy = Barycentrics.UVW_dy.y * TexCoord10 + Barycentrics.UVW_dy.z * TexCoord20;
    
    CustomParameters materialParameter = _customParameters[materialIndex];
    Texture2D albedoTexture = _textures[NonUniformResourceIndex(materialParameter._albedoTextureIndex)];
    
    float3 baseColor = albedoTexture.SampleGrad(_sampler, texcoords, ddx, ddy).rgb;
    
#if ENABLE_SDF    
    bool shadow = raytraceShadow(worldPosition, normalize(float3(-1, -1, -1)));
#else
    bool shadow = false;
#endif
    
    return float4(lerp(baseColor, float3(0, 0, 0), shadow ? 0.5 : 0), 1.0);
    return float4(baseColor, 1);
    return float4(texcoords, 0, 1);
    return float4(worldPosition/10.0, 1);
    //return float4(_position.xy / float2(1920, 1080), 0, 1);
}
#endif

#if FORWARD_PASS
float4 main(VertexOut input) : SV_TARGET
{
    CustomParameters materialParameter = _customParameters[input._materialIndex];
    Texture2D albedoTexture = _textures[NonUniformResourceIndex(materialParameter._albedoTextureIndex)];
    float3 baseColor = albedoTexture.Sample(_sampler, input._texcoord).rgb;
    
#if ENABLE_SDF    
    bool shadow = raytraceShadow(input._worldPosition, normalize(float3(-1, -1, -1)));
#else
    bool shadow = false;
#endif

    //return float4(float3(sdfInstanceCount, sdfGridIndex, 0) / 100.0, 1);
    
    //return float4(sdfInstanceCount, 0.1, 0, 1);
    //return float4(debugTotalStep / 20.0, 0, 0, 1);
    return float4(lerp(baseColor, float3(0, 0, 0), shadow ? 0.5 : 0), 1.0);
}
#endif