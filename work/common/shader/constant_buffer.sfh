#define FRUSTUM_PLANE_COUNT 6
#define FLT_MAX 3.402823466e+38
#define UINT16_MAX 65535
#define UINT32_MAX 4294967295

struct ViewInfo {
    float4x4 _matrixView;
    float4x4 _matrixProj;
    float4x4 _matrixViewProj;
    float3 _position;
    uint _padding1;
    float2 _nearAndFarClip;
    float2 _halfFovTan;
    uint2 _viewPortSize;
    uint2 _padding2;
    float3 _upDirection;
    uint _padding4;
    float4 _frustumPlanes[FRUSTUM_PLANE_COUNT];
};

struct DirectionalLight {
    float3 _direction;
    float3 _color;
};

struct CustomParameters {
    float4 _color;
    uint _albedoTextureIndex;
};

// Values used to linearize the Z buffer (http://www.humus.name/temp/Linearize%20depth.txt)
float computeLinerDepth(float nonLinerDepth, float nearClip, float farClip){
    float farNear = farClip / nearClip;
    float invFarNear = 1.0 - farNear;
    return 1.0 / (invFarNear * nonLinerDepth + farNear);
}

// AABBの法線方向に最も近いポイントを探す
float3 getPositivePoint(float3 boundsMin, float3 boundsMax, float3 planeNormal){
	float3 result = boundsMin;
	float3 size = boundsMax - boundsMin;

	result.x += planeNormal.x > 0.0 ? size.x : 0.0;
	result.y += planeNormal.y > 0.0 ? size.y : 0.0;
	result.z += planeNormal.z > 0.0 ? size.z : 0.0;
	return result;
}

float3 getNegativePoint(float3 boundsMin, float3 boundsMax, float3 planeNormal) {
    return getPositivePoint(boundsMin, boundsMax, -planeNormal);
}

float3 getCameraDirection(ViewInfo viewInfo){
    return viewInfo._frustumPlanes[4].xyz;
}

bool doFrustumCulling(float3 boundMin, float3 boundsMax, ViewInfo viewInfo) {
    for (uint i = 0; i < FRUSTUM_PLANE_COUNT; ++i) {
        float4 planeNormal = viewInfo._frustumPlanes[i];
	    float3 positivePoint = getPositivePoint(boundMin, boundsMax, planeNormal.xyz);
	    float length = dot(planeNormal.xyz, positivePoint) - planeNormal.w;

	    if (length < 0) {
		    return false;
	    }
	 }
    
    return true;
}

// バウンディングボックスの最もカメラに近い距離を取得します。
float getNearBoundsDepth(float3 boundMin, float3 boundsMax, ViewInfo viewInfo) {
    float3 viewNormalAndDistance = getCameraDirection(viewInfo);
    float3 worldPositivePoint = getPositivePoint(boundMin, boundsMax, -viewNormalAndDistance);
    float3 viewPositivePoint = worldPositivePoint - viewInfo._position;
    return dot(viewNormalAndDistance, viewPositivePoint);
}

float getViewSpacePositivePosition(float3 boundMin, float3 boundsMax, float3 direction, ViewInfo viewInfo){
    float3 worldPositivePoint = getPositivePoint(boundMin, boundsMax, direction);
    float3 viewPositivePoint = worldPositivePoint - viewInfo._position;
    return dot(direction, viewPositivePoint);
}

float sampleHiz(uint2 hizSize, uint2 sampleCount, uint2 textureCoords, Texture2D<float> hizTexture){
    float hizDepthValue = 0.0;
    for(uint x = 0; x < sampleCount.x; ++x){
        for(uint y = 0; y < sampleCount.y; ++y){
            uint2 coords = min(textureCoords + uint2(x, y), hizSize);
            float depth = hizTexture[coords];
            hizDepthValue = max(hizDepthValue, depth);
        }
    }
    
    return hizDepthValue;    
}

bool isOcclusion(float depth, float3 boundsMin, float3 boundsMax, ViewInfo viewInfo){
    float viewDepthRange = viewInfo._nearAndFarClip.y - viewInfo._nearAndFarClip.x;
    float linerDepth = computeLinerDepth(depth, viewInfo._nearAndFarClip.x, viewInfo._nearAndFarClip.y);
    float viewDepth = viewInfo._nearAndFarClip.x + linerDepth * viewDepthRange;
    float boundsDepth = getNearBoundsDepth(boundsMin, boundsMax, viewInfo);
    return boundsDepth <= viewDepth;
}

bool computeHizLevelAndCoords(float3 boundsMin, float3 boundsMax, ViewInfo viewInfo, 
        out uint outHizLevel, out uint2 outCoords, out uint2 outSampleCount, out uint2 outHizSize) {
    float3 boundsSize = boundsMax - boundsMin;
    float3 viewSpaceBoundsMin = boundsMin - viewInfo._position;
#define POINT_COUNT 8
    const float3 points[] = {
        float3(0, 0, 0),
        float3(boundsSize.x, 0, 0),
        float3(0, boundsSize.y, 0),
        float3(boundsSize.xy, 0),
        float3(0, 0, boundsSize.z),
        float3(boundsSize.x, 0, boundsSize.z),
        float3(0, boundsSize.yz),
        boundsSize,
    };
    
    float3 cameraDirection = getCameraDirection(viewInfo);
    float3 viewUp = viewInfo._upDirection;
    float3 viewRight = cross(viewUp, cameraDirection);
    
    // 投影時のbounds rectを計算
    float2 screenCoordsMin = float2(FLT_MAX, FLT_MAX);
    float2 screenCoordsMax = float2(-FLT_MAX, -FLT_MAX);
    for (uint i = 0; i < POINT_COUNT; ++i) {
        float3 p = viewSpaceBoundsMin + points[i];
        float2 viewSpacePosition = float2(dot(viewRight, p), dot(viewUp, p));
        float viewDepth = max(dot(cameraDirection, p), 0.001);
        float2 halfViewSize = viewInfo._halfFovTan * viewDepth;
        float2 clipSpacePosition = viewSpacePosition / halfViewSize; // -1.0 ~ 1.0
        float2 screenCoords = saturate(clipSpacePosition / 2.0 + 0.5); // 0.0 ~ 1.0
        screenCoords.y = 1.0 - screenCoords.y; // テクスチャ座標系に変換。テクスチャ座標系は下方向がY+ 
            
        screenCoordsMin = min(screenCoordsMin, screenCoords);
        screenCoordsMax = max(screenCoordsMax, screenCoords);
    }
        
    outHizLevel = 0;
    outHizSize = uint2(0, 0);
    outCoords = uint2(0, 0);
    outSampleCount = uint2(0, 0);
    
    uint hizLevelMax = 8;
    float powScale = 1.0;
    float2 screenSize = screenCoordsMax - screenCoordsMin;
    for (uint level = 0; level < hizLevelMax; ++level){
        powScale *= 2.0;
        float2 hizSize = float2(viewInfo._viewPortSize) / powScale;
        float2 hizLevelPixelSize = 1.0 / hizSize;
        if (screenSize.x < hizLevelPixelSize.x && screenSize.y < hizLevelPixelSize.y) {
            uint2 coordsMin = uint2(screenCoordsMin * hizSize);
            uint2 coordsMax = uint2(screenCoordsMax * hizSize);
            uint2 hizSizeU = viewInfo._viewPortSize / powScale;
            hizSizeU += hizSizeU % 2;
            outHizSize = hizSizeU - 1;
            outHizLevel = level;
            outCoords = coordsMin;
            outSampleCount = coordsMax - coordsMin + uint2(1, 1);
            return true;
        }
    }
    
    return false;
}

float2 unpackTexCoords(uint packed) {
    uint x = (packed.x >> 0) & 0xffff;
    uint y = (packed.x >> 16) & 0xffff;
    float div = UINT16_MAX / 8.0;
    return (float2(x, y) / div) - 4.0;
}