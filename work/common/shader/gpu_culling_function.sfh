#include "gpu_driven.sfh"
#include "constant_buffer.sfh"
#include "util.sfh"

struct MeshletBounds {
    float3 _boundsMin;
    float3 _boundsMax;
    float3 _normal;
    float _apexOffset;
    float _cutoff;
};

bool isEnabledMeshInstance(MeshInstance meshInstance) {
    return meshInstance._stateFlags != 0;
}

MeshletBounds computeTransformedBounds(float4x3 matrixWorld, float worldScale, Meshlet meshlet){
    float3 boundsMin = meshlet._aabbMin;
    float3 boundsMax = meshlet._aabbMax;
    float3 boundsSize = boundsMax - boundsMin;
    
    float3 worldMatrixCol0 = matrixWorld[0].xyz * boundsSize.x;
    float3 worldMatrixCol1 = matrixWorld[1].xyz * boundsSize.y;
    float3 worldMatrixCol2 = matrixWorld[2].xyz * boundsSize.z;
    float3 boundsWorldMin = mul(float4(boundsMin, 1.0), matrixWorld);
    
    const float3 points[8] = {
        worldMatrixCol0 + worldMatrixCol1 + worldMatrixCol2,
        worldMatrixCol0 + worldMatrixCol1,
        worldMatrixCol0,
        float3(0, 0, 0),
        worldMatrixCol0 + worldMatrixCol2,
        worldMatrixCol2,
        worldMatrixCol1 + worldMatrixCol2,
        worldMatrixCol1
    };
    
    float3 resultBoundsMin = float3(FLT_MAX, FLT_MAX, FLT_MAX);
    float3 resultBoundsMax = float3(-FLT_MAX, -FLT_MAX, -FLT_MAX);
    for (uint pointIndex = 0; pointIndex < 8; ++pointIndex) {
        resultBoundsMin = min(resultBoundsMin, boundsWorldMin + points[pointIndex]);
        resultBoundsMax = max(resultBoundsMax, boundsWorldMin + points[pointIndex]);
    }
    
    float4 normalCone = UnpackCone(meshlet._normalAndCutoff);
    float3 resultBoundsNormal = mul(normalCone.xyz, (float3x3)matrixWorld);
    
    MeshletBounds bounds;
    bounds._boundsMin = resultBoundsMin;
    bounds._boundsMax = resultBoundsMax;
    bounds._normal = resultBoundsNormal / worldScale;
    bounds._apexOffset = meshlet._apexOffset * worldScale;
    bounds._cutoff = normalCone.w * worldScale;
    return bounds;
}

float3 getCameraDirection(ViewInfo viewInfo)
{
    return viewInfo._frustumPlanes[4].xyz;
}

bool doFrustumCulling(float3 boundMin, float3 boundsMax, ViewInfo viewInfo)
{
    for (uint i = 0; i < FRUSTUM_PLANE_COUNT; ++i)
    {
        float4 planeNormal = viewInfo._frustumPlanes[i];
        float3 positivePoint = getPositivePoint(boundMin, boundsMax, planeNormal.xyz);
        float length = dot(planeNormal.xyz, positivePoint) - planeNormal.w;

        if (length < 0)
        {
            return false;
        }
    }
    
    return true;
}

bool doNdcCulling(float2 screenCoordsMin, float2 screenCoordsMax, ViewInfo viewInfo)
{
    float2 screenSize = float2(viewInfo._viewPortSize);
    float2 roundScreenMin = round(screenCoordsMin * screenSize);
    float2 roundScreenMax = round(screenCoordsMax = screenSize);
    if (roundScreenMin.x == roundScreenMax.x)
    {
        return false;
    }
    
    if (roundScreenMin.y == roundScreenMax.y)
    {
        return false;
    }
    
    return true;
}

// バウンディングボックスの最もカメラに近い距離を取得します。
float getNearBoundsDepth(float3 boundMin, float3 boundsMax, ViewInfo viewInfo)
{
    float3 viewNormalAndDistance = getCameraDirection(viewInfo);
    float3 worldPositivePoint = getPositivePoint(boundMin, boundsMax, -viewNormalAndDistance);
    float3 viewPositivePoint = worldPositivePoint - viewInfo._position;
    return dot(viewNormalAndDistance, viewPositivePoint);
}

float getViewSpacePositivePosition(float3 boundMin, float3 boundsMax, float3 direction, ViewInfo viewInfo)
{
    float3 worldPositivePoint = getPositivePoint(boundMin, boundsMax, direction);
    float3 viewPositivePoint = worldPositivePoint - viewInfo._position;
    return dot(direction, viewPositivePoint);
}

float sampleHiz(uint2 hizSize, uint2 sampleCount, uint2 textureCoords, Texture2D<float> hizTexture)
{
    float hizDepthValue = 0.0;
    for (uint x = 0; x < sampleCount.x; ++x)
    {
        for (uint y = 0; y < sampleCount.y; ++y)
        {
            uint2 coords = min(textureCoords + uint2(x, y), hizSize);
            float depth = hizTexture[coords];
            hizDepthValue = max(hizDepthValue, depth);
        }
    }
    
    return hizDepthValue;
}

bool isOcclusion(float depth, float3 boundsMin, float3 boundsMax, ViewInfo viewInfo)
{
    float viewDepthRange = viewInfo._nearAndFarClip.y - viewInfo._nearAndFarClip.x;
    float linerDepth = computeLinerDepth(depth, viewInfo._nearAndFarClip.x, viewInfo._nearAndFarClip.y);
    float viewDepth = viewInfo._nearAndFarClip.x + linerDepth * viewDepthRange;
    float boundsDepth = getNearBoundsDepth(boundsMin, boundsMax, viewInfo);
    return boundsDepth <= viewDepth;
}

void computeScreenRect(float3 boundsMin, float3 boundsMax, ViewInfo viewInfo, out float2 outScreenCoordsMin, out float2 outScreenCoordsMax)
{
    float3 boundsSize = boundsMax - boundsMin;
    float3 viewSpaceBoundsMin = boundsMin - viewInfo._position;
#define POINT_COUNT 8
    const float3 points[] =
    {
        float3(0, 0, 0),
        float3(boundsSize.x, 0, 0),
        float3(0, boundsSize.y, 0),
        float3(boundsSize.xy, 0),
        float3(0, 0, boundsSize.z),
        float3(boundsSize.x, 0, boundsSize.z),
        float3(0, boundsSize.yz),
        boundsSize,
    };
    
    float3 cameraDirection = getCameraDirection(viewInfo);
    float3 viewUp = viewInfo._upDirection;
    float3 viewRight = cross(viewUp, cameraDirection);
    
    // 投影時のbounds rectを計算
    float2 screenCoordsMin = float2(FLT_MAX, FLT_MAX);
    float2 screenCoordsMax = float2(-FLT_MAX, -FLT_MAX);
    for (uint i = 0; i < POINT_COUNT; ++i)
    {
        float3 p = viewSpaceBoundsMin + points[i];
        float2 viewSpacePosition = float2(dot(viewRight, p), dot(viewUp, p));
        float viewDepth = max(dot(cameraDirection, p), 0.001);
        float2 halfViewSize = viewInfo._halfFovTan * viewDepth;
        float2 clipSpacePosition = viewSpacePosition / halfViewSize; // -1.0 ~ 1.0
        float2 screenCoords = saturate(clipSpacePosition / 2.0 + 0.5); // 0.0 ~ 1.0
        screenCoords.y = 1.0 - screenCoords.y; // テクスチャ座標系に変換。テクスチャ座標系は下方向がY+ 
            
        screenCoordsMin = min(screenCoordsMin, screenCoords);
        screenCoordsMax = max(screenCoordsMax, screenCoords);
    }
    
    outScreenCoordsMin = screenCoordsMin;
    outScreenCoordsMax = screenCoordsMax;
}

bool computeHizLevelAndCoords(float2 screenCoordsMin, float2 screenCoordsMax, ViewInfo viewInfo,
        out uint outHizLevel, out uint2 outCoords, out uint2 outSampleCount, out uint2 outHizSize)
{
    outHizLevel = 0;
    outHizSize = uint2(0, 0);
    outCoords = uint2(0, 0);
    outSampleCount = uint2(0, 0);
    
    uint hizLevelMax = 8;
    float powScale = 1.0;
    float2 screenSize = screenCoordsMax - screenCoordsMin;
    for (uint level = 0; level < hizLevelMax; ++level)
    {
        powScale *= 2.0;
        float2 hizSize = float2(viewInfo._viewPortSize) / powScale;
        float2 hizLevelPixelSize = 1.0 / hizSize;
        if (screenSize.x < hizLevelPixelSize.x && screenSize.y < hizLevelPixelSize.y)
        {
            uint2 coordsMin = uint2(screenCoordsMin * hizSize);
            uint2 coordsMax = uint2(screenCoordsMax * hizSize);
            uint2 hizSizeU = viewInfo._viewPortSize / powScale;
            hizSizeU += hizSizeU % 2;
            outHizSize = hizSizeU - 1;
            outHizLevel = level;
            outCoords = coordsMin;
            outSampleCount = coordsMax - coordsMin + uint2(1, 1);
            return true;
        }
    }
    
    return false;
}

bool frustumCullingBoundingBox(float3 boundsMin, float3 boundsMax, ViewInfo viewInfo)
{
    for (uint i = 0; i < FRUSTUM_PLANE_COUNT; ++i)
    {
        float4 planeNormal = viewInfo._frustumPlanes[i];
        float3 positivePoint = getPositivePoint(boundsMin, boundsMax, planeNormal.xyz);
        float planeDistance = planeNormal.w;
        float length = dot(planeNormal.xyz, positivePoint) - planeDistance;

        if (length < 0)
        {
            return false;
        }
    }
    
    return true;
}