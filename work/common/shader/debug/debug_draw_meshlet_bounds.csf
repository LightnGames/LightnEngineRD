#include "../gpu_culling_function.sfh"

struct LineInstance {
	float3 _startPosition;
	float3 _endPosition;
	float4 _color;
};

ConstantBuffer<SceneCullingInfo> _sceneCullingInfo : register(b0);
StructuredBuffer<Mesh> _meshes : register(t0);
StructuredBuffer<LodMesh> _lodMeshes : register(t1);
StructuredBuffer<SubMesh> _subMeshes : register(t2);
StructuredBuffer<Meshlet> _meshlets : register(t3);
StructuredBuffer<MeshInstance> _meshInstances : register(t4);
ByteAddressBuffer _currentLodLevels : register(t5);

RWStructuredBuffer <LineInstance> _lineInstances : register(u0);
RWByteAddressBuffer _drawArguments : register(u1);

void storeDebugLine(uint index, float3 start, float3 end){
    LineInstance lineInstance;
    lineInstance._startPosition = start;
    lineInstance._endPosition = end;
    lineInstance._color = float4(0.5, 0.5, 0, 1.0);
    _lineInstances[index] = lineInstance;
}

#define NUM_POINTS 12
#define THREAD_NUM 128
[numthreads(THREAD_NUM, 1, 1)] 
void main(in uint3 groupID : SV_GroupID, in uint3 groupThreadID : SV_GroupThreadID) {
    uint meshInstanceIndex = groupID.x * THREAD_NUM + groupThreadID.x;
    if (meshInstanceIndex > (_sceneCullingInfo._meshInstanceCount - 1)) {
        return;
    }
	
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    if (meshInstance._stateFlags == 0) {
        return;
    }
    
    Mesh mesh = _meshes[meshInstance._meshIndex];
    if(mesh._stateFlags == MESH_STATE_ALLOCATED){
        mesh = _meshes[0];
    }
    
    uint currentLodLevel = _currentLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE);
    LodMesh lodMesh =_lodMeshes[mesh._lodMeshOffset + currentLodLevel];
    
    uint currentMeshletDebugIndex = 0;
    uint debugLineCount = 0;
    for (uint subMeshIndex = 0; subMeshIndex < lodMesh._subMeshCount; ++subMeshIndex){
        SubMesh subMesh = _subMeshes[lodMesh._subMeshOffset + subMeshIndex];
        debugLineCount += subMesh._meshletCount * NUM_POINTS;
    }
    _drawArguments.InterlockedAdd(UINT32_SIZE_IN_BYTE, debugLineCount, currentMeshletDebugIndex);
	
    uint meshletCounter = 0;
    for (subMeshIndex = 0; subMeshIndex < lodMesh._subMeshCount; ++subMeshIndex){
        SubMesh subMesh = _subMeshes[lodMesh._subMeshOffset + subMeshIndex];
        for(uint meshletIndex = 0; meshletIndex < subMesh._meshletCount; ++meshletIndex){
            MeshletBounds meshletBounds = computeTransformedBounds(meshInstance, _meshlets[subMesh._meshletOffset + meshletIndex]);
	        float3 boundsMin = meshletBounds._boundsMin;
	        float3 boundsMax = meshletBounds._boundsMax;
            float3 size = boundsMax - boundsMin;
	        float3 right = float3(1, 0, 0) * size.x;
	        float3 up = float3(0, 1, 0) * size.y;
	        float3 forward = float3(0, 0, 1) * size.z;
            
            uint storeOffset = currentMeshletDebugIndex + meshletCounter * NUM_POINTS;
            storeDebugLine(storeOffset + 0, boundsMin, boundsMin + right);
            storeDebugLine(storeOffset + 1, boundsMin, boundsMin + forward);
            storeDebugLine(storeOffset + 2, boundsMin + forward, boundsMin + forward + right);
            storeDebugLine(storeOffset + 3, boundsMin + right, boundsMin + forward + right);
            
            storeDebugLine(storeOffset + 4, boundsMin, boundsMin + up);
            storeDebugLine(storeOffset + 5, boundsMax, boundsMax - up);
            storeDebugLine(storeOffset + 6, boundsMin + forward, boundsMin + forward + up);
            storeDebugLine(storeOffset + 7, boundsMax - forward, boundsMax - forward - up);
            
            storeDebugLine(storeOffset + 8, boundsMax, boundsMax - right);
            storeDebugLine(storeOffset + 9, boundsMax, boundsMax - forward);
            storeDebugLine(storeOffset +10, boundsMax - forward, boundsMax - forward - right);
            storeDebugLine(storeOffset +11, boundsMax - right, boundsMax - forward - right);
            meshletCounter++;
        }
    }
}