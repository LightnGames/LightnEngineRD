#include "../shaderInput.sfh"
#include "../constant_buffer.sfh"
#include "../gpu_driven.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b0);
StructuredBuffer<float4x3> _sdfBoundsInvWorldMatrics : register(t0);
Texture3D _sdf[] : register(t1);
sampler _linerSampler : register(s1);

float sampleSdf(uint textureIndex, float3 localPosition) {
    return _sdf[textureIndex].Sample(_linerSampler, localPosition + float3(0.5, 0.5, 0.5)).x;
}

float4 main(SdfPSInput input) : SV_TARGET {
    float3 viewDirection = normalize(_viewInfo._cameraPosition - input._worldPosition);
    float3 invViewDirection = normalize(-viewDirection);
    float3x3 meshInstanceScaleRotateMatrix = (float3x3) _sdfBoundsInvWorldMatrics[input._meshInstanceIndex];
    float3 rayDirection = mul(invViewDirection, meshInstanceScaleRotateMatrix);
    bool isHit = false;
    float rayDistance = 0.01;
    int SAMPLE_COUNT_MAX = 256;
    for (int i = 0; i < SAMPLE_COUNT_MAX; ++i) {
        float3 currentRayOrigin = input._localPosition + rayDistance * rayDirection;
        if (currentRayOrigin.x < -0.5 || currentRayOrigin.x > 0.5)
        {
            break;
        }
        
        if (currentRayOrigin.y < -0.5 || currentRayOrigin.y > 0.5)
        {
            break;
        }
        
        if (currentRayOrigin.z < -0.5 || currentRayOrigin.z > 0.5)
        {
            break;
        }
        
        float distance = sampleSdf(input._meshIndex, currentRayOrigin);
        
        float minStepSize = 1.0f / (4 * SAMPLE_COUNT_MAX);
        float stepDistance = max(distance, minStepSize);
        rayDistance += stepDistance;
        
        if (distance < 0)
        {
            isHit = true;
            break;
        }
    }
    
    //return float4(rayDirection, 1);
    //return float4(sampleSdf(1, input._localPosition), 0.2, 0.2, 0.8);
    if (!isHit)
    {
        clip(-1);
    }
    
    return float4(float3(1.0, 0.3, 0.3), 1);
}