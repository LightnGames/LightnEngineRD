#include "../shaderInput.sfh"
#include "../constant_buffer.sfh"
#include "../gpu_driven.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b0);
StructuredBuffer<float4x3> _sdfBoundsInvWorldMatrics : register(t0);
Texture3D _sdf[] : register(t1);
sampler _linerSampler : register(s1);

float sampleSdf(uint textureIndex, float3 localPosition) {
    return _sdf[textureIndex].SampleLevel(_linerSampler, localPosition + float3(0.5, 0.5, 0.5), 0).x;
}

float4 main(SdfPSInput input) : SV_TARGET {
    float3 viewDirection = normalize(_viewInfo._cameraPosition - input._worldPosition);
    float3 invViewDirection = -viewDirection;
    float3x3 meshInstanceScaleRotateMatrix = (float3x3) _sdfBoundsInvWorldMatrics[input._meshInstanceIndex];
    float3 rayDirection = mul(meshInstanceScaleRotateMatrix, invViewDirection);
    float rayEndThreshold = 0.01;
    bool isHit = false;
    float rayDistance = 0.0;
    int SAMPLE_COUNT_MAX = 64;
    for (int i = 0; i < SAMPLE_COUNT_MAX; ++i) {
        float3 currentRayOrigin = input._localPosition + rayDistance * rayDirection;
        float distance = sampleSdf(1, currentRayOrigin);
        if (distance < rayEndThreshold) {
            isHit = true;
            break;
        }
        
        rayDistance += distance * 0.5;
    }
    
    //return float4(rayDirection, 1);
    //return float4(sampleSdf(1, input._localPosition), 0.2, 0.2, 0.8);
    if (!isHit) {
        clip(-1);
    }
    
    return float4(float3(rayDistance, 0.3, 0.3), 0.7);
}