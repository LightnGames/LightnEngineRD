#include "../shaderInput.sfh"
#include "../constant_buffer.sfh"
#include "../gpu_driven.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b0);
StructuredBuffer<float4x3> _sdfBoundsInvWorldMatrics : register(t0);
Texture3D _sdf[] : register(t1);
sampler _linerSampler : register(s1);

float sampleSdf(uint textureIndex, float3 localPosition) {
    return _sdf[textureIndex].Sample(_linerSampler, localPosition + float3(0.5, 0.5, 0.5)).x;
}

float4 main(SdfPSInput input) : SV_TARGET {
    float3 viewDirection = normalize(_viewInfo._cameraPosition - input._worldPosition);
    float3 invViewDirection = -viewDirection;
    float3x3 meshInstanceScaleRotateMatrix = (float3x3) _sdfBoundsInvWorldMatrics[input._meshInstanceIndex];
    float3 rayDirection = mul(invViewDirection, meshInstanceScaleRotateMatrix);
    rayDirection = normalize(rayDirection);
    float rayEndThreshold = 0.01;
    bool isHit = false;
    float rayDistance = 0.0;
    int SAMPLE_COUNT_MAX = 32;
    for (int i = 0; i < SAMPLE_COUNT_MAX; ++i) {
        float3 currentRayOrigin = input._localPosition + rayDistance * rayDirection;
        float distance = sampleSdf(input._meshIndex, currentRayOrigin);
        if (distance < rayEndThreshold) {
            isHit = true;
            break;
        }
        
        rayDistance += distance;
    }
    
    //return float4(rayDirection, 1);
    //return float4(sampleSdf(1, input._localPosition), 0.2, 0.2, 0.8);
    if (!isHit) {
        clip(-1);
    }
    
    return float4(float3(rayDistance, 0.3, 0.3), 0.9);
}