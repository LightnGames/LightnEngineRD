#include "../constant_buffer.sfh"
#include "../util.sfh"

struct ComputeSdfConstant
{
    uint3 _resolution;
    uint _indexCount;
    float3 _sdfBoundsMin;
    uint _indexOffset;
    float3 _sdfBoundsMax;
    uint _vertexOffset;
    float _cellSize;
};

ConstantBuffer<ComputeSdfConstant> _constant : register(b0);
StructuredBuffer<uint> _indices : register(t0);
StructuredBuffer<float3> _vertexPositions : register(t1);

RWTexture3D<float> _outSdf : register(u0);

/* Returns the position (relative to the triangle buffer) of the voxel id. */
float3 PositionFromVoxelId(uint3 id)
{
    float cellSize = _constant._cellSize;
    float halfCellSize = cellSize / 2.0;
    float3 resolution = float3(_constant._resolution);
    float3 offset = resolution * halfCellSize;
    float3 boundsCenterOffset = (_constant._sdfBoundsMin + _constant._sdfBoundsMax) / 2.0;
    float3 voxelPosition = float3(id);
    return voxelPosition * cellSize + boundsCenterOffset - offset + float3(halfCellSize, halfCellSize, halfCellSize);
}

float mag2(float3 a)
{
    return (a.x * a.x) + (a.y * a.y) + (a.z * a.z);
}

float dist(float3 a, float3 b)
{
    return sqrt(mag2(a - b));
}

// find distance x0 is from segment x1-x2
float point_segment_distance(float3 x0, float3 x1, float3 x2)
{
    float3 dx = x2 - x1;
    float m2 = mag2(dx);
	// find parameter value of closest point on segment
    float s12 = (float) (dot(x2 - x0, dx) / m2);
    if (s12 < 0)
    {
        s12 = 0;
    }
    else if (s12 > 1)
    {
        s12 = 1;
    }
	// and find the distance
    return dist(x0, s12 * x1 + (1 - s12) * x2);
}

// find distance x0 is from triangle x1-x2-x3
float point_triangle_distance(float3 x0, float3 x1, float3 x2, float3 x3)
{
	// first find barycentric coordinates of closest point on infinite plane
    float3 x13 = (x1 - x3);
    float3 x23 = (x2 - x3);
    float3 x03 = (x0 - x3);
    float m13 = mag2(x13);
    float m23 = mag2(x23);
    float d = dot(x13, x23);
    float invdet = 1.f / max(m13 * m23 - d * d, 1e-30f);
    float a = dot(x13, x03);
    float b = dot(x23, x03);
	// the barycentric coordinates themselves
    float w23 = invdet * (m23 * a - d * b);
    float w31 = invdet * (m13 * b - d * a);
    float w12 = 1 - w23 - w31;
    if (w23 >= 0 && w31 >= 0 && w12 >= 0)
    { // if we're inside the triangle
        return dist(x0, w23 * x1 + w31 * x2 + w12 * x3);
    }
    else
    { // we have to clamp to one of the edges
        if (w23 > 0) // this rules out edge 2-3 for us
            return min(point_segment_distance(x0, x1, x2), point_segment_distance(x0, x1, x3));
        else if (w31 > 0) // this rules out edge 1-3
            return min(point_segment_distance(x0, x1, x2), point_segment_distance(x0, x2, x3));
        else // w12 must be >0, ruling out edge 1-2
            return min(point_segment_distance(x0, x1, x3), point_segment_distance(x0, x2, x3));
    }
}


/* Returns the unsigned distance between the input position and triangle.
Developed by Inigo Quilez. */
float DistanceToTriangle(float3 position, uint triangleId)
{
    uint t1 = _constant._vertexOffset + _indices[triangleId * 3];
    uint t2 = _constant._vertexOffset + _indices[triangleId * 3 + 1];
    uint t3 = _constant._vertexOffset + _indices[triangleId * 3 + 2];
    float3 pa = _vertexPositions[t1];
    float3 pb = _vertexPositions[t2];
    float3 pc = _vertexPositions[t3];
    return point_triangle_distance(position, pa, pb, pc);
}

bool frontfaceTriangle(uint triangleId, float3 position)
{
    uint t1 = _constant._vertexOffset + _indices[triangleId * 3];
    uint t2 = _constant._vertexOffset + _indices[triangleId * 3 + 1];
    uint t3 = _constant._vertexOffset + _indices[triangleId * 3 + 2];
    float3 v0 = _vertexPositions[t1];
    float3 v1 = _vertexPositions[t2];
    float3 v2 = _vertexPositions[t3];
    float3 trianglePosition = (v0 + v1 + v2) / 3.0;
    float3 toTriangleDirection = position - trianglePosition;
    
    float3 v0v1 = v1 - v0;
    float3 v0v2 = v2 - v0;
    float3 normal = cross(v0v1, v0v2);
    return dot(toTriangleDirection, normal) > 0;
}

// calculate twice signed area of triangle (0,0)-(x1,y1)-(x2,y2)
// return an SOS-determined sign (-1, +1, or 0 only if it's a truly degenerate triangle)
int orientation(float x1, float y1, float x2, float y2, inout float twice_signed_area)
{
    twice_signed_area = y1 * x2 - x1 * y2;
    if (twice_signed_area > 0)
        return 1;
    else if (twice_signed_area < 0)
        return -1;
    else if (y2 > y1)
        return 1;
    else if (y2 < y1)
        return -1;
    else if (x1 > x2)
        return 1;
    else if (x1 < x2)
        return -1;
    else
        return 0; // only true when x1==x2 and y1==y2
}

// robust test of (x0,y0) in the triangle (x1,y1)-(x2,y2)-(x3,y3)
// if true is returned, the barycentric coordinates are set in a,b,c.
bool point_in_triangle_2d(float x0, float y0,
	float x1, float y1, float x2, float y2, float x3, float y3,
	inout float a, inout float b, inout float c)
{
    x1 -= x0;
    x2 -= x0;
    x3 -= x0;
    y1 -= y0;
    y2 -= y0;
    y3 -= y0;
    int signa = orientation(x2, y2, x3, y3, a);
    if (signa == 0)
        return false;
    int signb = orientation(x3, y3, x1, y1, b);
    if (signb != signa)
        return false;
    int signc = orientation(x1, y1, x2, y2, c);
    if (signc != signa)
        return false;
    float sum = a + b + c;
    a /= sum;
    b /= sum;
    c /= sum;
    return true;
}

/* Returns whether a ray intersects a triangle. Developed by Möller–Trumbore. */
int RayIntersectsTriangle(float3 o, float3 d, uint triangleId)
{
    uint t1 = _constant._vertexOffset + _indices[triangleId * 3];
    uint t2 = _constant._vertexOffset + _indices[triangleId * 3 + 1];
    uint t3 = _constant._vertexOffset + _indices[triangleId * 3 + 2];
    float3 v0 = _vertexPositions[t1];
    float3 v1 = _vertexPositions[t2];
    float3 v2 = _vertexPositions[t3];
    
    float3 v0v1 = v1 - v0;
    float3 v0v2 = v2 - v0;
    float3 pvec = cross(d, v0v2);
    float det = dot(v0v1, pvec);
    
    // ray and triangle are parallel if det is close to 0
    if (abs(det) < EPSILON)
    {
        return 0;
    }
    
    float invDet = 1 / det;
 
    float3 tvec = o - v0;
    float u = dot(tvec, pvec) * invDet;
    if (u < 0 || u > 1)
    {
        return 0;
    }
 
    float3 qvec = cross(tvec, v0v1);
    float v = dot(d, qvec) * invDet;
    if (v < 0 || u + v > 1)
    {
        return 0;
    }
 
    float t = dot(v0v2, qvec) * invDet;
    //return t > EPSILON ? 1 : 0;
    
    if (t < EPSILON)
    {
        return 0;
    }
    float3 normal = cross(v0v1, v0v2);
    return dot(d, normal) > 0 ? 1 : -1;
}

/* Returns the index of the nearest triangle to the input position. */
float NearestTriangleDistance(float3 position)
{
    float distance = 10000.0;
    uint triangleStrat = _constant._indexOffset / 3;
    uint triangleEnd = triangleStrat + _constant._indexCount / 3;
    bool frontface = true;
    for (uint t = triangleStrat; t < triangleEnd; t++)
    {
        float triangleDistance = DistanceToTriangle(position, t);
        if (triangleDistance < distance)
        {
            distance = triangleDistance;
            frontface = frontfaceTriangle(t, position);
        }
    }
    
    bool backface = !frontface;
    int s = backface ? -1 : 1;
    return distance * s;
}

uint3 To3D(uint id)
{
    uint3 resolution = _constant._resolution;
    uint xy = resolution.x * resolution.y;
    uint z = id / xy;
    uint zQ = id % xy;
    
    uint y = zQ / resolution.x;
    uint x = zQ % resolution.x;
    return uint3(x, y, z);
}

#define THREAD_NUM 32
[numthreads(THREAD_NUM, 1, 1)]
void main(uint gid : SV_GroupID, uint gtid : SV_GroupThreadID, uint dtid : SV_DispatchThreadID)
{
    uint countMax = _constant._resolution.x * _constant._resolution.y * _constant._resolution.z;
    if (dtid >= countMax)
    {
        return;
    }
    
    uint3 voxelId = To3D(dtid);
    float3 pos = PositionFromVoxelId(voxelId);
    float distance = NearestTriangleDistance(pos);
    _outSdf[voxelId] = distance;
}