#include "meshlet_culling_template.sfh"

RWByteAddressBuffer _cullingResult : register(u0);

[numthreads(THREAD_NUM, 1, 1)]
void main(uint gid : SV_GroupID, uint gtid : SV_GroupThreadID, uint dtid : SV_DispatchThreadID)
{
    bool visible = false;
    BatchedSubMeshInfo batchedSubMeshInfo = _batchedSubMeshInfos[_batchedSubMeshInfoIndex._index];
    uint meshletLocalIndex = dtid % batchedSubMeshInfo._meshletCountMax;
    uint meshInstanceOffset = dtid / batchedSubMeshInfo._meshletCountMax;
    uint meshletIndex = batchedSubMeshInfo._meshletIndex + meshletLocalIndex;
    if (meshInstanceOffset < batchedSubMeshInfo._meshletCountMax)
    {
        visible = true;
    }
    
    if (visible) {
        uint index = WavePrefixCountBits(visible);
        writePayloadStruct(index, meshletIndex, batchedSubMeshInfo);
        
        uint currentCount = 0;
        Meshlet meshlet = _meshlets[meshletIndex];
        _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_TRIANGLE_COUNT_OFFSET, meshlet._primitiveCount, currentCount);
        _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
    
        _cullingResult.InterlockedAdd(TEST_BACKFACE_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
    
        _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        _cullingResult.InterlockedAdd(PASSED_BACKFACE_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
   
        _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_TRIANGLE_COUNT_OFFSET, meshlet._primitiveCount, currentCount);
        _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
    }
    
    uint visibleCount = WaveActiveCountBits(visible);
    DispatchMesh(visibleCount, 1, 1, _passMeshlets);
}