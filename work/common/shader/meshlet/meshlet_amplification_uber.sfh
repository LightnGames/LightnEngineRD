#include "../gpu_culling_function.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b1);
ConstantBuffer<IndirectArgumentConstant> _indirectArgumentConstant : register(b2);

StructuredBuffer<CustomParameters> _customParameters : register(t0);
StructuredBuffer<Mesh> _meshes : register(t1);
StructuredBuffer<LodMesh> _lodMeshes : register(t2);
StructuredBuffer<SubMesh> _subMeshes : register(t3);
StructuredBuffer<Meshlet> _meshlets : register(t4);

StructuredBuffer<MeshInstance> _meshInstances : register(t5);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t6);
StructuredBuffer<SubMeshInstance> _subMeshInstances : register(t7);
StructuredBuffer<MeshletInstanceInfo> _meshletInstanceInfos : register(t9);
#if UBER_OCCLUSION
Texture2D<float> _hizTextures[8] : register(t16);
#endif

#if UBER_CULLING_RESULT
RWByteAddressBuffer _cullingResult : register(u0);
#endif

#define THREADS_PER_WAVE 32
#define THREAD_NUM THREADS_PER_WAVE
groupshared PayloadStruct _passMeshlets;

bool doBackFaceCulling(MeshletBounds meshletBounds) {
    float3 boundsCenter = (meshletBounds._boundsMin + meshletBounds._boundsMax) / 2.0;
    float3 apexDirection = meshletBounds._normal * meshletBounds._apexOffset;
    float3 offsetedBoundsCenter = boundsCenter - apexDirection;
    float3 viewDirection = normalize(_viewInfo._position - offsetedBoundsCenter);
    float3 axis = -meshletBounds._normal;
    float viewAngle = dot(axis, viewDirection);
    return !(viewAngle > meshletBounds._cutoff);
}

void writePayloadStruct(uint visibleIndex, Meshlet meshlet, MeshletInstanceInfo meshletInfo) {
    _passMeshlets._meshletVertexCounts[visibleIndex] = meshlet._vertexCount;
    _passMeshlets._meshletPrimitiveCounts[visibleIndex] = meshlet._primitiveCount;
    _passMeshlets._meshInstanceIndices[visibleIndex] = meshletInfo._meshInstanceIndex;
    _passMeshlets._materialIndex[visibleIndex] = meshletInfo._materialIndex;
    _passMeshlets._vertexOffset[visibleIndex] = meshletInfo._vertexOffset;
    _passMeshlets._vertexIndexOffset[visibleIndex] = meshletInfo._vertexIndexOffset + meshlet._vertexOffset;
    _passMeshlets._primitiveOffset[visibleIndex] = meshletInfo._primitiveOffset + meshlet._primitiveOffset;
}

[numthreads(THREAD_NUM, 1, 1)]
void main(uint gid : SV_GroupID, uint gtid : SV_GroupThreadID, uint dtid : SV_DispatchThreadID)
{
    bool passFrustum = false;
    bool passBackface = false;
    bool passOcclusion = false;
    bool visible = false;
    bool isTestedFrustumCulling = false;
    bool isTestedBackfaceCulling = false;
    bool isTestedOcclusionCulling = false;
    uint testFrustumPrimitiveCount = 0;
    uint testBackfacePrimitiveCount = 0;
    uint testOcclusionPrimitiveCount = 0;
    uint passFrustumPrimitiveCount = 0;
    uint passBackfacePrimitiveCount = 0;
    uint passOcclusionPrimitiveCount = 0;
    uint unpackedOffset = 0xffff;
    bool isPacked = false;
    
    uint meshletCount = _indirectArgumentConstant._meshletCount;
    uint meshletOffset = dtid % meshletCount;
    uint instanceOffset = dtid / meshletCount;
    uint meshletInfoOffset = _indirectArgumentConstant._meshletInstanceInfoOffset + instanceOffset;
    if (instanceOffset < _indirectArgumentConstant._instanceCount) {
        MeshletInstanceInfo meshletInfo = _meshletInstanceInfos[meshletInfoOffset];
        uint meshletIndex = meshletInfo._meshletIndex + meshletOffset;
        Meshlet meshlet = _meshlets[meshletIndex];
        MeshInstance meshInstance = _meshInstances[meshletInfo._meshInstanceIndex];
        MeshletBounds meshletBounds = computeTransformedBounds(meshInstance, meshlet);
        ViewInfo viewInfo = _viewInfo;
        float3 boundsMin = meshletBounds._boundsMin;
        float3 boundsMax = meshletBounds._boundsMax;
        visible = true;

#if UBER_FRUSTUM
        passFrustum = doFrustumCulling(boundsMin, boundsMax, viewInfo);
        isTestedFrustumCulling = true;
        testFrustumPrimitiveCount = meshlet._primitiveCount;
        visible = passFrustum;
#endif
        
#if UBER_BACKFACE
        if (passFrustum) {
            passBackface = doBackFaceCulling(meshletBounds);
            isTestedBackfaceCulling = true;
            visible = passBackface;
        }
#endif
    
#if UBER_OCCLUSION
        if (passBackface) {
            uint hizLevel;
            uint2 leftTopCoords;
            uint2 sampleCount;
            uint2 hizSize;
            isTestedOcclusionCulling = computeHizLevelAndCoords(boundsMin, boundsMax, viewInfo, hizLevel, leftTopCoords, sampleCount, hizSize);
            if (isTestedOcclusionCulling) {
                float hizDepthValue = sampleHiz(hizSize, sampleCount, leftTopCoords, _hizTextures[NonUniformResourceIndex(hizLevel)]);
                passOcclusion = isOcclusion(hizDepthValue, boundsMin, boundsMax, viewInfo);
                visible = passOcclusion;
            }
        }
#endif
        
        if (visible) {
            uint index = WavePrefixCountBits(visible);
            writePayloadStruct(index, meshlet, meshletInfo);
            
            //if (meshletOffset == meshletCount - 1) {
            //    uint instancePerGroup = min(64 / meshlet._vertexCount, 126 / meshlet._primitiveCount);
            //    isPacked = true;
            //    visible = (WavePrefixCountBits(isPacked) % instancePerGroup) == 0;
            //    unpackedOffset = index;
            //}
        }
    }
    
    
#if UBER_CULLING_RESULT
    if (instanceOffset < _indirectArgumentConstant._instanceCount) {
        MeshletInstanceInfo meshletInfo = _meshletInstanceInfos[meshletInfoOffset];
        uint meshletIndex = meshletInfo._meshletIndex + meshletOffset;
        Meshlet meshlet = _meshlets[meshletIndex];
        if (passFrustum) {
            passFrustumPrimitiveCount = meshlet._primitiveCount;
            testBackfacePrimitiveCount = meshlet._primitiveCount;
        }
    
        if (passBackface) {
            testOcclusionPrimitiveCount = meshlet._primitiveCount;
            passBackfacePrimitiveCount = meshlet._primitiveCount;
        }
    
        if (passOcclusion) {
            passOcclusionPrimitiveCount = meshlet._primitiveCount;
        }
    
        uint currentCount = 0;
        if (isTestedFrustumCulling) {
            _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_TRIANGLE_COUNT_OFFSET, testFrustumPrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    
        if (isTestedBackfaceCulling) {
            _cullingResult.InterlockedAdd(TEST_BACKFACE_CULLING_TRIANGLE_COUNT_OFFSET, testBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(TEST_BACKFACE_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    
        if (isTestedOcclusionCulling) {
            _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_TRIANGLE_COUNT_OFFSET, testOcclusionPrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }

        if (passFrustum) {
            _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_TRIANGLE_COUNT_OFFSET, passFrustumPrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    
        if (passBackface) {
            _cullingResult.InterlockedAdd(PASSED_BACKFACE_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(PASSED_BACKFACE_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
        
        if (passOcclusion) {
            _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_TRIANGLE_COUNT_OFFSET, passOcclusionPrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    }
#endif
        
    _passMeshlets._unpackedCount = 0;
    _passMeshlets._unpackedOffset = 0;
    if (WaveActiveCountBits(isPacked) > 0) {
        _passMeshlets._unpackedCount = WaveActiveCountBits(isPacked);
        _passMeshlets._unpackedOffset = WaveActiveMin(unpackedOffset);
    }
    
    uint visibleCount = WaveActiveCountBits(visible);
    DispatchMesh(visibleCount, 1, 1, _passMeshlets);
}