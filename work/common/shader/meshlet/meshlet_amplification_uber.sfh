#include "../gpu_culling_function.sfh"

ConstantBuffer<ViewInfo> _viewInfo : register(b1);
ConstantBuffer<MeshShaderIndirectArgument> _indirectArgumentConstant : register(b2);

StructuredBuffer<CustomParameters> _customParameters : register(t0);
StructuredBuffer<Mesh> _meshes : register(t1);
StructuredBuffer<LodMesh> _lodMeshes : register(t2);
StructuredBuffer<SubMesh> _subMeshes : register(t3);
StructuredBuffer<Meshlet> _meshlets : register(t4);
StructuredBuffer<MeshletPrimitiveInfo> _meshletPrimitiveInfos : register(t5);

StructuredBuffer<MeshInstance> _meshInstances : register(t6);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t7);
StructuredBuffer<SubMeshInstance> _subMeshInstances : register(t8);
StructuredBuffer<MeshletInstancePrimitiveInfo> _meshletInstanceInfos : register(t10);
StructuredBuffer<uint> _meshletInstanceMeshInstanceIndices : register(t18);
StructuredBuffer<float4x3> _meshInstanceWorldMatrics : register(t19);

#if UBER_OCCLUSION
Texture2D<float> _hizTextures[8] : register(t20);
#endif

#if UBER_CULLING_RESULT
RWByteAddressBuffer _cullingResult : register(u0);
#endif

#define THREADS_PER_WAVE 32
#define THREAD_NUM THREADS_PER_WAVE
groupshared PayloadStruct _passMeshlets;

bool doBackFaceCulling(MeshletBounds meshletBounds) {
    float3 boundsCenter = (meshletBounds._boundsMin + meshletBounds._boundsMax) / 2.0;
    float3 apexDirection = meshletBounds._normal * meshletBounds._apexOffset;
    float3 offsetedBoundsCenter = boundsCenter - apexDirection;
    float3 viewDirection = normalize(_viewInfo._cameraPosition - offsetedBoundsCenter);
    float3 axis = -meshletBounds._normal;
    float viewAngle = dot(axis, viewDirection);
    return !(viewAngle > meshletBounds._cutoff);
}

void writePayloadStruct(uint visibleIndex, uint meshInstanceIndex, MeshletPrimitiveInfo meshlet, MeshletInstancePrimitiveInfo meshletInfo) {
    _passMeshlets._meshletVertexCounts[visibleIndex] = meshlet._vertexCount;
    _passMeshlets._meshletPrimitiveCounts[visibleIndex] = meshlet._primitiveCount;
    _passMeshlets._meshInstanceIndices[visibleIndex] = meshInstanceIndex;
    _passMeshlets._materialIndex[visibleIndex] = meshletInfo._materialIndex;
    _passMeshlets._vertexOffset[visibleIndex] = meshletInfo._vertexOffset;
    _passMeshlets._vertexIndexOffset[visibleIndex] = meshletInfo._vertexIndexOffset + meshlet._vertexOffset;
    _passMeshlets._primitiveOffset[visibleIndex] = meshletInfo._primitiveOffset + meshlet._primitiveOffset;
}

[numthreads(THREAD_NUM, 1, 1)]
void main(uint gid : SV_GroupID, uint gtid : SV_GroupThreadID, uint dtid : SV_DispatchThreadID) {
    bool passFrustum = false;
    bool passNdc = false;
    bool passBackface = false;
    bool passOcclusion = false;
    bool visible = false;
    bool isTestedFrustumCulling = false;
    bool isTestedNdcCulling = false;
    bool isTestedBackfaceCulling = false;
    bool isTestedOcclusionCulling = false;
    uint unpackedOffset = 0xffff;
    bool isPacked = false;
    
    uint meshletCount = _indirectArgumentConstant._meshletCount;
    uint instanceCount = _indirectArgumentConstant._instanceCount;
    uint meshletOffset = dtid / instanceCount;
    uint instanceOffset = dtid % instanceCount;
    uint meshletInfoOffset = _indirectArgumentConstant._meshletInstanceInfoOffset + instanceOffset;
    if (instanceOffset < instanceCount && meshletOffset < meshletCount) {
        MeshletInstancePrimitiveInfo meshletInfo = _meshletInstanceInfos[meshletInfoOffset];
        uint meshletIndex = _indirectArgumentConstant._meshletOffset + meshletOffset;
        uint meshInstanceIndex = _meshletInstanceMeshInstanceIndices[meshletInfoOffset];
        Meshlet meshlet = _meshlets[meshletIndex];
        MeshletPrimitiveInfo meshletPrimitive = _meshletPrimitiveInfos[meshletIndex];
        MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
        float4x3 matrixWorld = _meshInstanceWorldMatrics[meshInstanceIndex];
        MeshletBounds meshletBounds = computeTransformedBounds(matrixWorld, meshInstance._worldScale, meshlet);
        ViewInfo viewInfo = _viewInfo;
        float3 boundsMin = meshletBounds._boundsMin;
        float3 boundsMax = meshletBounds._boundsMax;
        visible = true;

#if UBER_NDC || UBER_OCCLUSION
        float2 screenCoordsMin;
        float2 screenCoordsMax;
        computeScreenRect(boundsMin, boundsMax, viewInfo, screenCoordsMin, screenCoordsMax);
#endif
        
#if UBER_FRUSTUM
        passFrustum = doFrustumCulling(boundsMin, boundsMax, viewInfo);
        isTestedFrustumCulling = true;
        visible = passFrustum;
#endif
        
#if UBER_NDC
        if (visible) {
            isTestedNdcCulling = true;
            passNdc = doNdcCulling(screenCoordsMin, screenCoordsMax, viewInfo);
            visible = passNdc;
        }
#endif
        
#if UBER_BACKFACE
        if (visible) {
            passBackface = doBackFaceCulling(meshletBounds);
            isTestedBackfaceCulling = true;
            visible = passBackface;
        }
#endif
    
#if UBER_OCCLUSION
        if (visible) {
            uint hizLevel;
            uint2 leftTopCoords;
            uint2 sampleCount;
            uint2 hizSize;
            isTestedOcclusionCulling = computeHizLevelAndCoords(screenCoordsMin, screenCoordsMax, viewInfo, hizLevel, leftTopCoords, sampleCount, hizSize);
            if (isTestedOcclusionCulling) {
                float hizDepthValue = sampleHiz(hizSize, sampleCount, leftTopCoords, _hizTextures[NonUniformResourceIndex(hizLevel)]);
                passOcclusion = isOcclusion(hizDepthValue, boundsMin, boundsMax, viewInfo);
                visible = passOcclusion;
            }
        }
#endif
        
        if (visible) {
            uint index = WavePrefixCountBits(visible);
            writePayloadStruct(index, meshInstanceIndex ,meshletPrimitive, meshletInfo);
            
            if (meshletOffset == meshletCount - 1) {
                uint instancePerGroup = min(64 / meshletPrimitive._vertexCount, 126 / meshletPrimitive._primitiveCount);
                isPacked = true;
                visible = (WavePrefixCountBits(isPacked) % instancePerGroup) == 0;
                unpackedOffset = index;
            }
        }
    }
    
    
#if UBER_CULLING_RESULT
    if (instanceOffset < _indirectArgumentConstant._instanceCount) {
        uint meshletIndex = _indirectArgumentConstant._meshletOffset + meshletOffset;
        MeshletPrimitiveInfo meshletPrimitive = _meshletPrimitiveInfos[meshletIndex];
        uint passBackfacePrimitiveCount = meshletPrimitive._primitiveCount;
        uint currentCount = 0;
        if (isTestedFrustumCulling) {
            _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    
        if (isTestedNdcCulling){
            _cullingResult.InterlockedAdd(TEST_NDC_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(TEST_NDC_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    
        if (isTestedBackfaceCulling) {
            _cullingResult.InterlockedAdd(TEST_BACKFACE_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(TEST_BACKFACE_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    
        if (isTestedOcclusionCulling) {
            _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }

        if (passFrustum) {
            _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    
        if (passNdc) {
            _cullingResult.InterlockedAdd(PASSED_NDC_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(PASSED_NDC_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    
        if (passBackface) {
            _cullingResult.InterlockedAdd(PASSED_BACKFACE_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(PASSED_BACKFACE_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
        
        if (passOcclusion) {
            _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_TRIANGLE_COUNT_OFFSET, passBackfacePrimitiveCount, currentCount);
            _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_MESHLET_INSTANCE_COUNT_OFFSET, 1, currentCount);
        }
    }
#endif
    
    _passMeshlets._unpackedCount = 0;
    _passMeshlets._unpackedOffset = 0;
    if (WaveActiveCountBits(isPacked) > 0) {
        _passMeshlets._unpackedCount = WaveActiveCountBits(isPacked);
        _passMeshlets._unpackedOffset = WaveActiveMin(unpackedOffset);
    }
    
    uint visibleCount = WaveActiveCountBits(visible);
    DispatchMesh(visibleCount, 1, 1, _passMeshlets);
}