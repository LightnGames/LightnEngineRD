#include "../gpu_culling_function.sfh"

struct DispatchMeshIndirectArgument {
    uint2 _meshletInfoGpuAddress;
    uint _dispatchX;
    uint _dispatchY;
    uint _dispatchZ;
};

ConstantBuffer<SceneCullingInfo> _sceneCullingInfo : register(b0);
ConstantBuffer<CullingViewInfo> _cullingViewInfo : register(b1);
ConstantBuffer<ViewInfo> _viewInfo :register(b2);
StructuredBuffer<Mesh> _meshes : register(t0);
StructuredBuffer<LodMesh> _lodMeshes : register(t1);
StructuredBuffer<SubMesh> _subMeshes : register(t2);
StructuredBuffer<MeshInstance> _meshInstances : register(t3);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t4);
StructuredBuffer<SubMeshInstance> _subMeshInstances : register(t5);
ByteAddressBuffer _indirectArgumentOffsets : register(t6);
ByteAddressBuffer _currentLodLevels : register(t7);
ByteAddressBuffer _packedMeshletOffsets : register(t8);
StructuredBuffer<SubMeshDrawInfo> _subMeshDrawInfos : register(t9);

RWStructuredBuffer<DispatchMeshIndirectArgument> _indirectArguments : register(u0);
RWByteAddressBuffer _countBuffer : register(u1);
RWStructuredBuffer<BatchedMeshletInfo> _batchedMeshletInfo : register(u2);
RWStructuredBuffer<PackedMeshletInfo> _packedMeshletInfos : register(u3);
RWByteAddressBuffer _packedMeshletCounts : register(u4);

#define THREAD_NUM 128
#define AMPLIFICATION_DISPATCH_NUM 32

bool isRangeMeshInstance(uint meshInstanceIndex) {
    return meshInstanceIndex < _sceneCullingInfo._meshInstanceCount;
}

bool isTested(uint meshInstanceIndex) {
    if (!isRangeMeshInstance(meshInstanceIndex)) {
        return false;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    if (!isEnabledMeshInstance(meshInstance)) {
        return false;
    }
    
    return true;
}

Mesh getMesh(MeshInstance meshInstance) {
    Mesh mesh = _meshes[meshInstance._meshIndex];
    if (mesh._stateFlags == MESH_STATE_ALLOCATED) {
        mesh = _meshes[0];
    }
    return mesh;
}

LodMesh getLodMesh(Mesh mesh, uint lodLevel) {
    uint lodMeshIndex = mesh._lodMeshOffset + lodLevel;
    return _lodMeshes[lodMeshIndex];
}

uint getMeshInstanceIndex(uint groupId, uint groupThreadId) {
    return groupId * THREAD_NUM + groupThreadId;
}

uint getCurrentLodLevel(uint meshInstanceIndex) {
    return _currentLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE);
}

void addIndirectArgument(uint meshInstanceIndex) {
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    Mesh mesh = getMesh(meshInstance);
    uint lodLevel = getCurrentLodLevel(meshInstanceIndex);
	
    LodMesh lodMesh = getLodMesh(mesh, lodLevel);
    uint subMeshCount = lodMesh._subMeshCount;
    
    LodMeshInstance lodMeshInstance = _lodMeshInstances[meshInstance._lodMeshInstanceOffset + lodLevel];
    for (uint subMeshLocalIndex = 0; subMeshLocalIndex < subMeshCount; ++subMeshLocalIndex) {
        SubMesh subMesh = _subMeshes[lodMesh._subMeshOffset + subMeshLocalIndex];
        SubMeshInstance subMeshInstance = _subMeshInstances[lodMeshInstance._subMeshInstanceOffset + subMeshLocalIndex];
		
        
        uint meshletCount = subMesh._meshletCount;
        if (meshletCount < 64) {
            uint shaderSetPackedOffset = subMeshInstance._shaderSetIndex * 64;
            uint offset = shaderSetPackedOffset + meshletCount;
            uint globalOffset = offset * UINT32_SIZE_IN_BYTE;

            uint packedOffset = _packedMeshletOffsets.Load(globalOffset);
            uint localOffset = 0;
            _packedMeshletCounts.InterlockedAdd(globalOffset, 1, localOffset);
            
            PackedMeshletInfo info;
            info._meshletIndex = subMesh._meshletOffset;
            info._meshInstanceIndex = meshInstanceIndex;
            info._materialIndex = subMeshInstance._materialIndex;
            info._vertexOffset = lodMesh._vertexOffset;
            info._vertexIndexOffset = lodMesh._vertexIndexOffset;
            info._primitiveOffset = lodMesh._primitiveOffset;
            _packedMeshletInfos[packedOffset + localOffset] = info;
            
            uint shaderSetOffset = subMeshInstance._shaderSetIndex * UINT32_SIZE_IN_BYTE;
            uint currentCountIndex = 0;
            _countBuffer.InterlockedMax(shaderSetOffset, meshletCount, currentCountIndex);
            
            uint totalMeshletCount = meshletCount * (localOffset + 1);
            uint dispatchCount = (totalMeshletCount / AMPLIFICATION_DISPATCH_NUM) + 1;
            
            uint2 meshletInfoAddress = _cullingViewInfo._meshletInfoGpuAddress;
            addUint64(meshletInfoAddress, MESHLET_INFO_SIZE_IN_BYTE * offset);
            
            _indirectArguments[offset]._meshletInfoGpuAddress = meshletInfoAddress;
            _indirectArguments[offset]._dispatchY = 1;
            _indirectArguments[offset]._dispatchZ = 1;
            InterlockedMax(_indirectArguments[offset]._dispatchX, dispatchCount);
		
            _batchedMeshletInfo[offset]._packedMeshletCount = meshletCount;
            _batchedMeshletInfo[offset]._packedMeshletOffset = packedOffset;
            InterlockedMax(_batchedMeshletInfo[offset]._totalMeshletCountMax, totalMeshletCount);
        }
    }
}