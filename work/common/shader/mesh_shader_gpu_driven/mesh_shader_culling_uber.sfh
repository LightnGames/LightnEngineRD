#include "../gpu_culling_function.sfh"
struct DispatchMeshIndirectArgument {
    IndirectArgumentConstant _constant;
    uint _dispatchX;
    uint _dispatchY;
    uint _dispatchZ;
};

ConstantBuffer<SceneCullingInfo> _sceneCullingInfo : register(b0);
ConstantBuffer<CullingViewInfo> _cullingViewInfo : register(b1);
ConstantBuffer<ViewInfo> _viewInfo :register(b2);
StructuredBuffer<Mesh> _meshes : register(t0);
StructuredBuffer<LodMesh> _lodMeshes : register(t1);
StructuredBuffer<SubMesh> _subMeshes : register(t2);
StructuredBuffer<MeshInstance> _meshInstances : register(t3);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t4);
StructuredBuffer<SubMeshInstance> _subMeshInstances : register(t5);
ByteAddressBuffer _indirectArgumentOffsets : register(t6);
ByteAddressBuffer _currentLodLevels : register(t7);
//StructuredBuffer<SubMeshDrawInfo> _subMeshDrawInfos : register(t8);
ByteAddressBuffer _meshletInstanceInfoOffsets : register(t9);
#if UBER_OCCLUSION
Texture2D<float> _hizTextures[] : register(t10);
#endif

#define ENABLE_MESHLET_INSTANCING 1
#define SHADER_SET_COUNT_MAX 32
#define MESHLET_INSTANCE_MESHLET_COUNT_MAX 64

RWStructuredBuffer<DispatchMeshIndirectArgument> _indirectArguments : register(u0);
RWByteAddressBuffer _indirectArgumentCounts : register(u1);
RWStructuredBuffer<MeshletInstanceInfo> _meshletInstanceInfos : register(u2);
RWByteAddressBuffer _meshletInstanceInfoCounts : register(u3);
#if UBER_CULLING_RESULT
RWByteAddressBuffer _cullingResult : register(u4);
#endif

#define THREAD_NUM 128
#define AMPLIFICATION_DISPATCH_NUM 32

bool isRangeMeshInstance(uint meshInstanceIndex) {
    return meshInstanceIndex < _sceneCullingInfo._meshInstanceCount;
}

bool isTested(uint meshInstanceIndex) {
    if (!isRangeMeshInstance(meshInstanceIndex)) {
        return false;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    if (!isEnabledMeshInstance(meshInstance)) {
        return false;
    }
    
    return true;
}

Mesh getMesh(MeshInstance meshInstance) {
    Mesh mesh = _meshes[meshInstance._meshIndex];
    if (mesh._stateFlags == MESH_STATE_ALLOCATED) {
        mesh = _meshes[0];
    }
    return mesh;
}

LodMesh getLodMesh(Mesh mesh, uint lodLevel) {
    uint lodMeshIndex = mesh._lodMeshOffset + lodLevel;
    return _lodMeshes[lodMeshIndex];
}

uint getMeshInstanceIndex(uint groupId, uint groupThreadId) {
    return groupId * THREAD_NUM + groupThreadId;
}

uint getCurrentLodLevel(uint meshInstanceIndex) {
    return _currentLodLevels.Load(meshInstanceIndex * UINT32_SIZE_IN_BYTE);
}

void addIndirectArgument(uint meshInstanceIndex) {
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    Mesh mesh = getMesh(meshInstance);
    uint lodLevel = getCurrentLodLevel(meshInstanceIndex);
	
    LodMesh lodMesh = getLodMesh(mesh, lodLevel);
    uint subMeshCount = lodMesh._subMeshCount;
    
    LodMeshInstance lodMeshInstance = _lodMeshInstances[meshInstance._lodMeshInstanceOffset + lodLevel];
    for (uint subMeshLocalIndex = 0; subMeshLocalIndex < subMeshCount; ++subMeshLocalIndex) {
        SubMesh subMesh = _subMeshes[lodMesh._subMeshOffset + subMeshLocalIndex];
        SubMeshInstance subMeshInstance = _subMeshInstances[lodMeshInstance._subMeshInstanceOffset + subMeshLocalIndex];
        
        uint meshletIndex = subMesh._meshletCount - 1;
        if (meshletIndex < MESHLET_INSTANCE_MESHLET_COUNT_MAX) {
            uint meshletInstanceOffsetByte = (subMeshInstance._shaderSetIndex * MESHLET_INSTANCE_MESHLET_COUNT_MAX + meshletIndex) * UINT32_SIZE_IN_BYTE;
            uint currentCount = 0;
            _meshletInstanceInfoCounts.InterlockedAdd(meshletInstanceOffsetByte, 1, currentCount);
            
            uint offset = _meshletInstanceInfoOffsets.Load(meshletInstanceOffsetByte);
            uint globalOffset = offset + currentCount;
            
            MeshletInstanceInfo meshletInfo;
            meshletInfo._meshletIndex = subMesh._meshletOffset;
            meshletInfo._meshInstanceIndex = meshInstanceIndex;
            meshletInfo._materialIndex = subMeshInstance._materialIndex;
            meshletInfo._vertexOffset = lodMesh._vertexOffset;
            meshletInfo._vertexIndexOffset = lodMesh._vertexIndexOffset;
            meshletInfo._primitiveOffset = lodMesh._primitiveOffset;
            _meshletInstanceInfos[globalOffset] = meshletInfo;
            
            continue;
        }
        
        uint shaderSetOffset = (subMeshInstance._shaderSetIndex + SHADER_SET_COUNT_MAX) * UINT32_SIZE_IN_BYTE;
        uint currentCountIndex = 0;
        _indirectArgumentCounts.InterlockedAdd(shaderSetOffset, 1, currentCountIndex);
	
        uint instancingOffset = SHADER_SET_COUNT_MAX * MESHLET_INSTANCE_MESHLET_COUNT_MAX;
        uint indirectArgumentShaderSetOffset = _indirectArgumentOffsets.Load(shaderSetOffset) + instancingOffset;
        uint indirectArgumentOffset = indirectArgumentShaderSetOffset + currentCountIndex;
        uint dispatchCount = (subMesh._meshletCount / AMPLIFICATION_DISPATCH_NUM) + 1;
        uint meshletInfoOffset = _meshletInstanceInfoOffsets.Load(instancingOffset) + currentCountIndex;
		
        DispatchMeshIndirectArgument arguments;
        arguments._constant._instanceCount = 1;
        arguments._constant._meshletCount = subMesh._meshletCount;
        arguments._constant._meshletInstanceInfoOffset = meshletInfoOffset;
        arguments._dispatchX = dispatchCount;
        arguments._dispatchY = 1;
        arguments._dispatchZ = 1;
        _indirectArguments[indirectArgumentOffset] = arguments;
		
        MeshletInstanceInfo meshletInfo;
        meshletInfo._meshletIndex = subMesh._meshletOffset;
        meshletInfo._meshInstanceIndex = meshInstanceIndex;
        meshletInfo._materialIndex = subMeshInstance._materialIndex;
        meshletInfo._vertexOffset = lodMesh._vertexOffset;
        meshletInfo._vertexIndexOffset = lodMesh._vertexIndexOffset;
        meshletInfo._primitiveOffset = lodMesh._primitiveOffset;
        _meshletInstanceInfos[meshletInfoOffset] = meshletInfo;
    }
}

[numthreads(THREAD_NUM, 1, 1)]
void main(uint gid : SV_GroupID, uint gtid : SV_GroupThreadID, uint dtid : SV_DispatchThreadID){
    uint meshInstanceIndex = dtid;
    if (!isTested(meshInstanceIndex)) {
        return;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    ViewInfo viewInfo = _viewInfo;
    float3 boundsMin = meshInstance._aabbMin;
    float3 boundsMax = meshInstance._aabbMax;
    bool passCulling = true;
    bool passFrustum = true;
    bool passOcclusion = true;
    bool testFrustum = false;
    bool testOcclusion = false;
    Mesh mesh = getMesh(meshInstance);
    uint lodLevel = getCurrentLodLevel(meshInstanceIndex);
	
    LodMesh lodMesh = getLodMesh(mesh, lodLevel);
    uint subMeshCount = lodMesh._subMeshCount;
#if UBER_FRUSTUM
    passFrustum = doFrustumCulling(boundsMin, boundsMax, viewInfo);
    testFrustum = true;
    passCulling = passFrustum;
#endif
    
#if UBER_OCCLUSION
    if (passFrustum) {
        uint hizLevel;
        uint2 coords;
        uint2 sampleSize;
        uint2 hizSize;
        testOcclusion = computeHizLevelAndCoords(boundsMin, boundsMax, viewInfo, hizLevel, coords, sampleSize, hizSize);
    
        uint currentCount = 0;
        if (testOcclusion) {
            float hizDepthValue = sampleHiz(hizSize, sampleSize, coords, _hizTextures[NonUniformResourceIndex(hizLevel)]);
            passOcclusion = isOcclusion(hizDepthValue, boundsMin, boundsMax, viewInfo);
        }
    }
    passCulling = passFrustum && passOcclusion;
#endif
    
#if UBER_CULLING_RESULT
    uint currentCount = 0;
    if (testFrustum) {
        _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_MESH_INSTANCE_COUNT_OFFSET, 1, currentCount);
        _cullingResult.InterlockedAdd(TEST_FRUSTUM_CULLING_SUBMESH_INSTANCE_COUNT_OFFSET, subMeshCount, currentCount);
    }
    
    if (testOcclusion) {
        _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_MESH_INSTANCE_COUNT_OFFSET, 1, currentCount);
        _cullingResult.InterlockedAdd(TEST_OCCLUSION_CULLING_SUBMESH_INSTANCE_COUNT_OFFSET, subMeshCount, currentCount);
    }
    
    if (passFrustum) {
        _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_MESH_INSTANCE_COUNT_OFFSET, 1, currentCount);
        _cullingResult.InterlockedAdd(PASSED_FRUSTUM_CULLING_SUBMESH_INSTANCE_COUNT_OFFSET, subMeshCount, currentCount);
    }
    
    if (passOcclusion) {
        _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_MESH_INSTANCE_COUNT_OFFSET, 1, currentCount);
        _cullingResult.InterlockedAdd(PASSED_OCCLUSION_CULLING_SUBMESH_INSTANCE_COUNT_OFFSET, subMeshCount, currentCount);
    }
#endif
    
    if (passCulling) {
        addIndirectArgument(meshInstanceIndex);
    }
}