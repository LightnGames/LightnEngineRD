#include "constant_buffer.sfh"
#include "gpu_driven.sfh"

ConstantBuffer<SceneCullingInfo> _sceneCullingInfo : register(b0);
ConstantBuffer<ViewInfo> _viewInfo :register(b1);
StructuredBuffer<Mesh> _meshes : register(t0);
StructuredBuffer<LodMesh> _lodMeshes : register(t1);
StructuredBuffer<MeshInstance> _meshInstances : register(t3);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t4);

RWByteAddressBuffer _resultLodLevels : register(u0);

bool isRangeMeshInstance(uint meshInstanceIndex) {
    return meshInstanceIndex < _sceneCullingInfo._meshInstanceCount;
}

bool isTestedMeshInstance(uint meshInstanceIndex) {
    if (!isRangeMeshInstance(meshInstanceIndex)) {
        return false;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    if (!isEnabledMeshInstance(meshInstance)) {
        return false;
    }
    
    return true;
}

#define THREAD_NUM 128
[numthreads(THREAD_NUM, 1, 1)] 
void main(in uint3 groupID : SV_GroupID, in uint3 groupThreadID : SV_GroupThreadID) {
    uint meshInstanceIndex = groupID.x * THREAD_NUM + groupThreadID.x;
    if (!isTestedMeshInstance(meshInstanceIndex)) {
        return;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    Mesh mesh = _meshes[meshInstance._meshIndex];
    if(mesh._stateFlags == MESH_STATE_ALLOCATED) {
        mesh = _meshes[0];
        return;
    }
	
    float3 boundsCenter = (meshInstance._aabbMin + meshInstance._aabbMax) / 2.0;
    float3 viewSpaceBoundsCenter = boundsCenter - _viewInfo._position;
    float boundsDepth = length(viewSpaceBoundsCenter);
    float screenRadius = meshInstance._boundsRadius / (_viewInfo._halfFovTan.y * boundsDepth);
    float screenDimeter = screenRadius * 2;
    float screenArea = screenDimeter * screenDimeter;
	
    uint lodLevel = mesh._lodMeshCount - 1;
    for (uint lodIndex = 0; lodIndex < mesh._lodMeshCount; ++lodIndex) {
        uint lodMeshIndex = meshInstance._lodMeshInstanceOffset + lodIndex;
        LodMeshInstance lodMeshInstance = _lodMeshInstances[lodMeshIndex];
		
        if (lodMeshInstance._threshhold < screenArea) {
            lodLevel = lodIndex;
            break;
        }
    }
	
    _resultLodLevels.Store(meshInstanceIndex * UINT32_SIZE_IN_BYTE, lodLevel);
}