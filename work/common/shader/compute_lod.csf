#include "constant_buffer.sfh"
#include "gpu_driven.sfh"

ConstantBuffer<SceneCullingInfo> _sceneCullingInfo : register(b0);
ConstantBuffer<ViewInfo> _viewInfo :register(b1);
StructuredBuffer<Mesh> _meshes : register(t0);
StructuredBuffer<LodMesh> _lodMeshes : register(t1);
StructuredBuffer<MeshInstance> _meshInstances : register(t3);
StructuredBuffer<LodMeshInstance> _lodMeshInstances : register(t4);
StructuredBuffer<SubMeshInstance> _subMeshInstances : register(t5);

RWByteAddressBuffer _resultLodLevels : register(u0);
RWByteAddressBuffer _requestMeshLodLevels : register(u1);
RWByteAddressBuffer _requestMaterialLodLevels : register(u2);

bool isRangeMeshInstance(uint meshInstanceIndex) {
    return meshInstanceIndex < _sceneCullingInfo._meshInstanceCount;
}

bool isTestedMeshInstance(uint meshInstanceIndex) {
    if (!isRangeMeshInstance(meshInstanceIndex)) {
        return false;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    if (!isEnabledMeshInstance(meshInstance)) {
        return false;
    }
    
    return true;
}

#define THREAD_NUM 128
[numthreads(THREAD_NUM, 1, 1)] 
void main(in uint3 groupID : SV_GroupID, in uint3 groupThreadID : SV_GroupThreadID) {
    uint meshInstanceIndex = groupID.x * THREAD_NUM + groupThreadID.x;
    if (!isTestedMeshInstance(meshInstanceIndex)) {
        return;
    }
    
    MeshInstance meshInstance = _meshInstances[meshInstanceIndex];
    Mesh mesh = _meshes[meshInstance._meshIndex];
    if(mesh._stateFlags == MESH_STATE_ALLOCATED) {
        mesh = _meshes[0];
        return;
    }
	
    float3 boundsCenter = (meshInstance._aabbMin + meshInstance._aabbMax) / 2.0;
    float3 viewSpaceBoundsCenter = boundsCenter - _viewInfo._cameraPosition;
    float boundsDepth = length(viewSpaceBoundsCenter);
    float screenRadius = meshInstance._boundsRadius / (_viewInfo._halfFovTan.y * boundsDepth);
    float screenDimeter = screenRadius * 2;
    float screenArea = screenDimeter * screenDimeter;
	
    uint lodLevel = mesh._lodMeshCount - 1;
    for (uint lodIndex = 0; lodIndex < mesh._lodMeshCount; ++lodIndex) {
        uint lodMeshIndex = meshInstance._lodMeshInstanceOffset + lodIndex;
        LodMeshInstance lodMeshInstance = _lodMeshInstances[lodMeshIndex];
		
        if (lodMeshInstance._threshhold < screenArea) {
            lodLevel = lodIndex;
            break;
        }
    }
	
    uint dummyValue = 0;
    uint currentLodLevel = max(lodLevel, mesh._streamedLodLevel);
    _resultLodLevels.Store(meshInstanceIndex * UINT32_SIZE_IN_BYTE, currentLodLevel);
    _requestMeshLodLevels.InterlockedMin(meshInstance._meshIndex * UINT32_SIZE_IN_BYTE, lodLevel, dummyValue);
    
    uint unorm16ScreenArea = screenArea * UINT16_MAX;
    LodMesh lodMesh = _lodMeshes[mesh._lodMeshOffset + lodLevel];
    LodMeshInstance lodMeshInstance = _lodMeshInstances[meshInstance._lodMeshInstanceOffset + lodLevel];
    uint subMeshCount = lodMesh._subMeshCount;
    for (uint i = 0; i < subMeshCount; ++i)
    {
        SubMeshInstance subMeshInstance = _subMeshInstances[lodMeshInstance._subMeshInstanceOffset + i];
        _requestMaterialLodLevels.InterlockedMin(subMeshInstance._materialIndex * UINT32_SIZE_IN_BYTE, unorm16ScreenArea, dummyValue);
    }
}